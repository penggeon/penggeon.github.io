<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STM32 CubeMX及HAL库学习</title>
    <url>/posts/3906.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>在拥有固件库开发的基础上，观看 Z小旋的博客-CSDN博客，能够快速上手 HAL 库。</p>
<p>下面对大佬的博客进行排序，方便查找。</p>
<p>这里推荐：<a href="https://blog.csdn.net/as480133937/category_9188655.html"> 【STM32】_Z小旋的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/98885316">【STM32】HAL库 STM32CubeMX教程一—安装教程</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/98947162">【STM32】HAL库 STM32CubeMX教程二—基本使用(新建工程点亮LED灯)</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/98983268">【STM32】HAL库 STM32CubeMX教程三—外部中断(HAL库GPIO讲解)_hal_gpio_exti_callback</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/99073783">【STM32】HAL库 STM32CubeMX教程四—UART串口通信详解_hal_uart_transmit</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/99121645">【STM32】HAL库 STM32CubeMX教程五—看门狗(独立看门狗,窗口看门狗)_stm32看门狗</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/99201209">【STM32】HAL库 STM32CubeMX教程六—定时器中断_hal_tim_irqhandler</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/99231677">【STM32】HAL库 STM32CubeMX教程七—PWM输出(呼吸灯)_stm32 hal pwm输出</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/99407485">【STM32】HAL库 STM32CubeMX教程八—定时器输入捕获_hal_tim_readcapturedvalue</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/99627062">【STM32】HAL库 STM32CubeMX教程九—ADC_stm32cubemx adc</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/102309242">【STM32】HAL库 STM32CubeMX教程十—DAC</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/104827639">【STM32】HAL库 STM32CubeMX教程十一—DMA (串口DMA发送接收)_cubemx spi dma</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/105259075">【STM32】HAL库 STM32CubeMX教程十二—IIC(读取AT24C02 )_cubemx iic</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/105741893">【STM32】HAL库 STM32CubeMX教程十三—RTC时钟_stm32 hal库的时钟</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/105849607">【STM32】HAL库 STM32CubeMX教程十四—SPI_cubemx spi</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/123455833">【STM32】HAL库 STM32CubeMX教程十五—FMC-SDRAM(一)_stm32cubemx fmc</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/123791568">【STM32】HAL库 STM32CubeMX教程十五—FMC-SDRAM(二)</a></p>
<h1 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h1><p><strong>1、串口</strong></p>
<p>初步写自己的具体逻辑，主要是串口，可以观看 <a href="https://www.bilibili.com/video/BV1q4411d7RX">STM32系列视频(CubeMX+MDK5+HAL库+库函数一站式学习)</a> 进行学习。</p>
<p>这个视频主要是标准库和 HAL库 函数都有，面向电源题类的。</p>
<p><strong>2、PID控制</strong></p>
<p>编码器测速：<a href="https://blog.csdn.net/qq_56089182/article/details/128767997">【STM32】使用HAL库进行电机测速，原理、代码、滤波</a></p>
<p>PID速度环：<a href="https://blog.csdn.net/qq_56089182/article/details/128768008">【STM32】使用HAL库进行电机速度环PID控制，代码+调参</a></p>
<p>PID位置环：<a href="https://blog.csdn.net/qq_56089182/article/details/128768033">【STM32】使用HAL库进行电机PID位置环控制，代码+调参</a></p>
<p><strong>3、PID调参</strong></p>
<p>VOFA+调参：<a href="https://blog.csdn.net/qq_56089182/article/details/128767976?spm=1001.2014.3001.5502">使用VOFA+上位机进行PID调参(附下位机代码)</a></p>
<p>VOFA+官网：<a href="https://www.vofa.plus/">VOFA+</a></p>
<p><strong>4、江科大OLED移植</strong></p>
<p>基于HAL库的stm32的OLED显示屏显示：<a href="https://blog.csdn.net/zhao710577624/article/details/129887136">基于HAL库的stm32的OLED显示屏显示（模拟I2C，四脚，0.96寸）</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>大佬的笔记整理：<a href="https://blog.csdn.net/wenhaiii/category_11376057.html">【单片机学习笔记】上传一整年的自学电子笔记，互相交流，共同进步</a></p>
<p>电赛国一大佬的方案：<a href="https://blog.csdn.net/qq_45204725/article/details/121375031">2021年全国大学生电子设计大赛F题——智能送药小车，全方位解决方案+程序代码（详细注释）山东赛区国奖</a></p>
]]></content>
      <categories>
        <category>大学生电子设计竞赛</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32中的预编译</title>
    <url>/posts/48839.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h1><p><strong>1、不带参宏定义</strong></p>
<p><code>#define</code>，宏定义命令，它也是C语言预处理命令的一种。</p>
<p>所谓宏定义，就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br></pre></td></tr></table></figure>

<p>在编译过程中遇到 N 时，会直接替换为 100。</p>
<p><strong>2、带参公定义</strong></p>
<p>宏定义可以携带参数。</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> M(y) y*y+3*y  <span class="comment">//宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 以下命令解释为 5*5+3*5</span></span><br><span class="line">    <span class="type">int</span> a = M(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、防止头文件重复包含</strong></p>
<p>如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __HEADER_One_H__ <span class="comment">// 意思是：宏开始行，如果还没有定义 __HEADER_One_H__ 则 进入，否则退出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HEADER_One_H__ <span class="comment">// 定义 __HEADER_One_H__</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// header1.h 头文件内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// 宏结束行</span></span></span><br></pre></td></tr></table></figure>

<p>模版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __x_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// 宏结束行</span></span></span><br></pre></td></tr></table></figure>

<h1 id="if-与-if-defined"><a href="#if-与-if-defined" class="headerlink" title="#if 与 #if defined"></a>#if 与 #if defined</h1><p><strong>1、<code>#if</code></strong></p>
<p><code>#if</code>的意思是如果宏条件符合，编译器就编译这段代码，否则，编译器就忽略这段代码而不编译，如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  A 0  <span class="comment">// 把A定义为0</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (A &gt; 1)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;A &gt; 1&quot;</span>);  <span class="comment">// 编译器没有编译该语句,该语句不生成汇编代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (A == 1)</span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;A == 1&quot;</span>); <span class="comment">// 编译器没有编译该语句,该语句不生成汇编代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;A &lt; 1&quot;</span>);   <span class="comment">// 编译器编译了这段代码，且生成了汇编代码，执行该语句</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>模版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> x</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> x</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> x</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>2、<code>#if defined</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (x)</span></span><br><span class="line">    ...code...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个<code>#if defined</code>它不管里面的 x 的逻辑是“真”还是“假”。它只管这个程序的前面的宏定义里面有没有定义 x 这个宏，如果定义了 x 这个宏，那么，编译器会编译中间的 <code>…code…</code>，否则会直接忽视中间的 <code>…code…</code> 代码。</p>
]]></content>
      <categories>
        <category>大学生电子设计竞赛</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32入门</title>
    <url>/posts/7474.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="必备知识"><a href="#必备知识" class="headerlink" title="必备知识"></a>必备知识</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>什么是 STM32：<a href="https://doc.embedfire.com/mcu/stm32/f103/hal_general/zh/latest/doc/chapter4/chapter4.html#id1">什么是STM32</a></p>
<p>STM32 能做什么：<a href="https://doc.embedfire.com/mcu/stm32/f103/hal_general/zh/latest/doc/chapter4/chapter4.html#id3">STM32能做什么</a></p>
<p>ST 官方官方网址：<a href="https://www.st.com/content/st_com/zh.html">ST官网 (st.com)</a></p>
<p>ST 官方中文网站：<a href="https://www.stmcu.com.cn/">STMCU中文官网</a></p>
<h2 id="型号"><a href="#型号" class="headerlink" title="型号"></a>型号</h2><p>STM32 怎么选型：<a href="https://doc.embedfire.com/mcu/stm32/f103/hal_general/zh/latest/doc/chapter4/chapter4.html#id7">STM32怎么选型</a></p>
<p>STM32 F1与F4的区别：<a href="https://shequ.stmicroelectronics.cn/thread-632128-1-1.html">【经验分享】ST公司STM32F4与STM32F1的区别</a></p>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p><strong>1、STM32 学习</strong></p>
<p>STM32 标准库开发：<a href="https://www.bilibili.com/video/BV1th411z7sn/">STM32入门教程-2023持续更新中</a></p>
<p>STM32 HAL库开发：<a href="https://www.bilibili.com/video/BV18X4y1M763?p=2&vd_source=c6a75c082f96f79b814a4b6c18035936">【野火】STM32 HAL库开发实战指南 教学视频 手把手教学STM32全系列</a></p>
<p><strong>2、Kicad</strong></p>
<p>KiCad 是一款 PCB 设计软件，优点是开源、有许多插件可用、有许多快捷键方便操作</p>
<p>学习路径：<a href="https://docs.kicad.org/6.0/zh/kicad/kicad.html#%E7%AE%80%E4%BB%8B">KiCad | 6.0 | 简体中文 | Documentation | KiCad</a></p>
<blockquote>
<p>PCB（Printed Circuit Board），中文名称为印制电路板，又称印刷线路板，是重要的电子部件，是电子元器件的支撑体，是电子元器件电气相互连接的载体。由于它是采用电子印刷术制作的，故被称为“印刷”电路板。</p>
<p>PCB 可以粗浅的理解为焊接死的面包板，目的是为了防止连线在搬运的过程中松动导致问题</p>
</blockquote>
<p><strong>3、部分项目学习</strong></p>
<p>可以通过学习他人的部分项目，深入对开发过程的理解</p>
<p>智能小车入门：<a href="https://www.bilibili.com/video/BV1SY411L7rJ">STM32智能小车教程-循迹-避障-蓝牙遥控-跟随-stm32f103c8t6-stm32最小系统-手把手入门教程</a></p>
<p>智能送药小车标准库：<a href="https://www.bilibili.com/video/BV1zg411e7Ri?p=1&vd_source=c6a75c082f96f79b814a4b6c18035936">电赛培训-基于21年赛题-智能送药小车</a></p>
<p>智能送药小车HAL库：<a href="https://www.bilibili.com/video/BV1UL411V7XK/">电赛“智能送药小车”【干货教程】STM32HAL库CubeMX+pid串级控制+OpenMV数字识别</a></p>
<p>智能送药小车：<a href="https://aitechtogether.com/article/2724.html">2021年电赛F题智能送药小车（国二）开源分享</a></p>
<p>其他智能送药小车：<a href="https://www.eetree.cn/project/detail/687">2021全国电赛真题（F）—— 智能送药小车</a></p>
<p>小车跟随行驶系统：<a href="https://blog.csdn.net/qq_52608074/article/details/126453231">2022电赛省一-小车跟随行驶系统（C题）</a></p>
<p>电磁炮：<a href="https://blog.csdn.net/weixin_38815998/article/details/99689190">2019电赛—-模拟电磁曲射炮</a></p>
<p>滚球：<a href="https://blog.csdn.net/weixin_38815998/article/details/99684652">电赛入坑—-2017年电赛国赛真题滚球控制系统</a></p>
<p><strong>4、电机</strong></p>
<p>电机快速初步了解：<a href="https://www.bilibili.com/video/BV1ig411S7gX/">有刷电机与无刷电机的原理</a></p>
<p>电机学习：<a href="https://www.bilibili.com/video/BV1kQ4y1y7Bf/">一个视频学完生活中的所有电机</a></p>
<p>电机驱动：<a href="https://www.bilibili.com/video/BV1BL4y187YF/">一个视频了解生活中电机的驱动控制及调速方法</a></p>
<p>以上均为快速了解，作为科普简单留下感性印象，下面的视频能更完善的学习电机</p>
<p>视频地址：<a href="https://www.bilibili.com/video/BV1AZ4y1V7wt?p=8&vd_source=c6a75c082f96f79b814a4b6c18035936">【野火】电机系列教学视频，基于STM32硬件（步进电机，直流有刷电机，直流无刷电机，舵机，永磁同步电机PMSM）PID闭环算法</a></p>
<p>在线文档：<a href="https://doc.embedfire.com/motor/motor_tutorial/zh/latest/README.html">【野火】电机应用开发实战指南—基于STM32</a></p>
<p><strong>5、PID算法</strong></p>
<p>电机中的 <a href="https://www.bilibili.com/video/BV1AZ4y1V7wt?p=8&vd_source=c6a75c082f96f79b814a4b6c18035936">野火视频</a> 有讲解，此外还有一些资源</p>
<p>PID理论学习：<a href="https://www.bilibili.com/video/BV1B54y1V7hp">从不懂到会用！PID从理论到实践~</a></p>
<p><strong>6、相关模块学习</strong></p>
<p>灰度传感器：<a href="https://blog.csdn.net/qq_41748900/article/details/102641330">一种双灰度传感器巡黑线方案</a></p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><h2 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h2><p>STM32F10xxx参考手册（中文）<a href="https://github.com/gzpeng233/STM32F103C8T6/blob/master/STM32F10xxx%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf">STM32F103C8T6&#x2F;STM32F10xxx参考手册（中文）</a></p>
<p>数据手册：<a href="https://github.com/gzpeng233/STM32F103C8T6/blob/master/STM32F103x8B%E6%95%B0%E6%8D%AE%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89.pdf">STM32F103C8T6&#x2F;STM32F103x8B数据手册（中文）</a></p>
<p>Cortex-M3权威指南：<a href="https://github.com/gzpeng233/STM32F103C8T6/blob/master/Cortex-M3%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf">STM32F103C8T6&#x2F;Cortex-M3权威指南</a></p>
<p>野火F103 标准库开发指南：<a href="https://doc.embedfire.com/mcu/stm32/f103mini/std/zh/latest/index.html">野火STM32库开发实战指南——基于野火MINI开发板</a></p>
<p>野火F103 HAL库开发指南：<a href="https://doc.embedfire.com/mcu/stm32/f103/hal_general/zh/latest/index.html">野火F103 HAL库开发指南</a></p>
<h2 id="HC-05模块"><a href="#HC-05模块" class="headerlink" title="HC-05模块"></a>HC-05模块</h2><p>概述：<a href="https://blog.csdn.net/qq_38410730/article/details/80368485">【常用模块】HC-05蓝牙串口通信模块使用详解（实例：手机蓝牙控制STM32单片机）</a></p>
<p>双机通信：<a href="http://ultirobot.com/2017/09/22/hc05communcation/">两个HC-05蓝牙互相连接方法</a></p>
<p>所有AT指令：<a href="https://www.taiwaniot.com.tw/wp-content/uploads/2016/01/ADIO-HC-05-1.pdf">HC-05 嵌入式蓝牙串口通讯模块 AT 指令集</a></p>
<div class="note info modern"><p>如果接受乱码，注意看波特率是否正确，默认值为9600！</p>
</div>

<p>STM32 接受蓝牙信息代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">My_USART1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStrue;</span><br><span class="line">    USART_InitTypeDef USART_InitStrue;</span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStrue;</span><br><span class="line"></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);  <span class="comment">//GPIO端口使能  </span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);  <span class="comment">//串口端口使能  </span></span><br><span class="line"></span><br><span class="line">    GPIO_InitStrue.GPIO_Mode=GPIO_Mode_AF_PP;  <span class="comment">// 模式: 复用输出</span></span><br><span class="line">    GPIO_InitStrue.GPIO_Pin=GPIO_Pin_9;  <span class="comment">// 引脚: A9</span></span><br><span class="line">    GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz;  <span class="comment">// 速度: 10MHz</span></span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStrue);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStrue.GPIO_Mode=GPIO_Mode_IN_FLOATING;  <span class="comment">// 模式: 浮空输入</span></span><br><span class="line">    GPIO_InitStrue.GPIO_Pin=GPIO_Pin_10;  <span class="comment">// 引脚: A10</span></span><br><span class="line">    GPIO_InitStrue.GPIO_Speed=GPIO_Speed_10MHz;  <span class="comment">// 速度: 10MHz</span></span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStrue);</span><br><span class="line"></span><br><span class="line">    USART_InitStrue.USART_BaudRate=<span class="number">9600</span>;  <span class="comment">// 波特率: 9600</span></span><br><span class="line">    USART_InitStrue.USART_HardwareFlowControl=USART_HardwareFlowControl_None;  <span class="comment">// 硬件流控制: 无</span></span><br><span class="line">    USART_InitStrue.USART_Mode=USART_Mode_Tx|USART_Mode_Rx;  <span class="comment">// 串口模式: 接受与发送</span></span><br><span class="line">    USART_InitStrue.USART_Parity=USART_Parity_No;  <span class="comment">// 极性: 无</span></span><br><span class="line">    USART_InitStrue.USART_StopBits=USART_StopBits_1;  <span class="comment">// 停止位: 1位</span></span><br><span class="line">    USART_InitStrue.USART_WordLength=USART_WordLength_8b;  <span class="comment">// 数据位长度: 8位</span></span><br><span class="line"></span><br><span class="line">    USART_Init(USART1,&amp;USART_InitStrue);</span><br><span class="line"></span><br><span class="line">    USART_Cmd(USART1,ENABLE);  <span class="comment">//使能串口1</span></span><br><span class="line"></span><br><span class="line">    USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);  <span class="comment">//开启接收中断</span></span><br><span class="line"></span><br><span class="line">    NVIC_InitStrue.NVIC_IRQChannel=USART1_IRQn;</span><br><span class="line">    NVIC_InitStrue.NVIC_IRQChannelCmd=ENABLE;</span><br><span class="line">    NVIC_InitStrue.NVIC_IRQChannelPreemptionPriority=<span class="number">1</span>;  <span class="comment">// 优先中断级别: 1</span></span><br><span class="line">    NVIC_InitStrue.NVIC_IRQChannelSubPriority=<span class="number">1</span>;  <span class="comment">// 普通中断级别: 1</span></span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStrue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 res;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET)</span><br><span class="line">    &#123;</span><br><span class="line">        res= USART_ReceiveData(USART1);</span><br><span class="line">        USART_SendData(USART1,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">    My_USART1_Init();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="电机控制"><a href="#电机控制" class="headerlink" title="电机控制"></a>电机控制</h2><p>电机驱动与编码器：<a href="https://blog.csdn.net/qq_46554815/article/details/113557435">TB6612与电机编码器</a></p>
<h2 id="超声波跟随"><a href="#超声波跟随" class="headerlink" title="超声波跟随"></a>超声波跟随</h2><p>HC-SR04模块：<a href="https://www.bilibili.com/video/BV1Dg4y1u71u/?p=30">超声波原理及测距</a></p>
<p>超声波跟随小车：<a href="https://www.bilibili.com/video/BV1Dg4y1u71u?p=36">超声波跟随小车</a></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>串口调试：<a href="https://www.bilibili.com/video/BV1Dg4y1u71u?p=27">USART-FlyMcu下载程序</a></p>
<div class="note info modern"><p>配合蓝牙模块可实现无线烧录功能</p>
</div>

<h2 id="红外遥控"><a href="#红外遥控" class="headerlink" title="红外遥控"></a>红外遥控</h2><p>介绍：<a href="https://blog.csdn.net/qq_40318498/article/details/97166387">STM32 红外遥控器详解</a></p>
]]></content>
      <categories>
        <category>大学生电子设计竞赛</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog常用模块总结</title>
    <url>/posts/27859.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>可以去小脚丫官网查询想要信息，链接 <a href="https://www.stepfpga.com/doc/">小脚丫STEP开源社区</a></p>
<h1 id="相关模块"><a href="#相关模块" class="headerlink" title="相关模块"></a>相关模块</h1><h2 id="时钟分频"><a href="#时钟分频" class="headerlink" title="时钟分频"></a>时钟分频</h2><p>带复位的时钟分频：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块名: divide</span></span><br><span class="line"><span class="comment"> * 描述: 带复位的时钟分频</span></span><br><span class="line"><span class="comment"> * 输入: 分频时钟</span></span><br><span class="line"><span class="comment"> * 输入: 复位信号</span></span><br><span class="line"><span class="comment"> * 输出: 分频后的输出时钟</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> divide (</span><br><span class="line">	<span class="keyword">input</span> clk,			<span class="comment">// 连接到FPGA的C1脚，频率为12MHz</span></span><br><span class="line">	<span class="keyword">input</span> rst_n,		<span class="comment">// 复位信号(低电平有效)</span></span><br><span class="line">	<span class="keyword">output</span> clkout		<span class="comment">// 分频后的时钟信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>	WIDTH	= <span class="number">3</span>;	<span class="comment">//计数器的位数，计数的最大值为 2**WIDTH-1</span></span><br><span class="line"><span class="keyword">parameter</span>	N	= <span class="number">5</span>;			<span class="comment">//分频系数，请确保 N &lt; 2**WIDTH-1，否则计数会溢出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	cnt_p,cnt_n;		<span class="comment">//cnt_p为上升沿触发时的计数器，cnt_n为下降沿触发时的计数器</span></span><br><span class="line"><span class="keyword">reg</span>	clk_p,clk_n;								<span class="comment">//clk_p为上升沿触发时分频时钟，clk_n为下降沿触发时分频时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上升沿触发的模N计数器</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n ) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		cnt_p&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cnt_p==(N-<span class="number">1</span>))</span><br><span class="line">		cnt_p&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> cnt_p&lt;=cnt_p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上升沿触发的分频时钟输出</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		clk_p&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cnt_p&lt;(N&gt;&gt;<span class="number">1</span>))</span><br><span class="line">		clk_p&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_p&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下降沿触发的模N计数器      	</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		cnt_n&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cnt_n==(N-<span class="number">1</span>))</span><br><span class="line">		cnt_n&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> cnt_n&lt;=cnt_n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下降沿触发的分频时钟输出</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst_n)</span><br><span class="line">		clk_n&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cnt_n&lt;(N&gt;&gt;<span class="number">1</span>))</span><br><span class="line">		clk_n&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		clk_n&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经过运算，输出占空比为50%的时钟信号 */</span></span><br><span class="line"><span class="comment">/* 输出 = N是否为1 ? 不分频: (N是否时奇数 ? 特殊处理 : 直接输出其中一个信号即可) */</span></span><br><span class="line"><span class="keyword">assign</span> clkout = (N==<span class="number">1</span>) ? clk : ( N[<span class="number">0</span>]?(clk_p&amp;clk_n):clk_p );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不带复位的时钟分频：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块名: divide</span></span><br><span class="line"><span class="comment"> * 描述: 不带复位的时钟分频</span></span><br><span class="line"><span class="comment"> * 输入: 分频时钟</span></span><br><span class="line"><span class="comment"> * 输出: 分频后的输出时钟</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> divide (</span><br><span class="line">	<span class="keyword">input</span> clk,			<span class="comment">// 连接到FPGA的C1脚，频率为12MHz</span></span><br><span class="line">	<span class="keyword">output</span> clkout		<span class="comment">// 分频后的时钟信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span>	WIDTH	= <span class="number">3</span>;	<span class="comment">//计数器的位数，计数的最大值为 2**WIDTH-1</span></span><br><span class="line"><span class="keyword">parameter</span>	N	= <span class="number">5</span>;			<span class="comment">//分频系数，请确保 N &lt; 2**WIDTH-1，否则计数会溢出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [WIDTH-<span class="number">1</span>:<span class="number">0</span>]	cnt_p,cnt_n;		<span class="comment">//cnt_p为上升沿触发时的计数器，cnt_n为下降沿触发时的计数器</span></span><br><span class="line"><span class="keyword">reg</span>	clk_p,clk_n;								<span class="comment">//clk_p为上升沿触发时分频时钟，clk_n为下降沿触发时分频时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上升沿触发的模N计数器</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (cnt_p==(N-<span class="number">1</span>))</span><br><span class="line">		cnt_p&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> cnt_p&lt;=cnt_p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上升沿触发的分频时钟输出</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (cnt_p&lt;(N&gt;&gt;<span class="number">1</span>))</span><br><span class="line">		clk_p&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		clk_p&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下降沿触发的模N计数器      	</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (cnt_n==(N-<span class="number">1</span>))</span><br><span class="line">		cnt_n&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> cnt_n&lt;=cnt_n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下降沿触发的分频时钟输出</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">negedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (cnt_n&lt;(N&gt;&gt;<span class="number">1</span>))</span><br><span class="line">		clk_n&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		clk_n&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 经过运算，输出占空比为50%的时钟信号 */</span></span><br><span class="line"><span class="comment">/* 输出 = N是否为1 ? 不分频: (N是否时奇数 ? 特殊处理 : 直接输出其中一个信号即可) */</span></span><br><span class="line"><span class="keyword">assign</span> clkout = (N==<span class="number">1</span>) ? clk : ( N[<span class="number">0</span>]?(clk_p&amp;clk_n):clk_p );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h2><p>对一个按键进行消抖(最基础)：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块名: debounce</span></span><br><span class="line"><span class="comment"> * 描述: 消抖模块</span></span><br><span class="line"><span class="comment"> * 输入: 1kHz时钟信号</span></span><br><span class="line"><span class="comment"> * 输入: 未消抖信号</span></span><br><span class="line"><span class="comment"> * 输出: 消抖信号</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> debounce(</span><br><span class="line">	<span class="keyword">input</span> clk_1kHz,			<span class="comment">// 时钟信号</span></span><br><span class="line">	<span class="keyword">input</span> key,					<span class="comment">// 输入</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> key_out	<span class="comment">// 防抖后输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]cnt;		<span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_1kHz)<span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!key)	<span class="comment">// 未按下按键,清除计数器</span></span><br><span class="line">		cnt&lt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">4&#x27;d10</span>)</span><br><span class="line">		cnt&lt;=<span class="number">4&#x27;d10</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cnt&lt;=cnt+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(cnt==<span class="number">4&#x27;d9</span>)</span><br><span class="line">		key_out&lt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		key_out&lt;=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>暂未确认正确：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> debounce (</span><br><span class="line">	<span class="keyword">input</span> clk,	<span class="comment">// 输入时钟</span></span><br><span class="line">	<span class="keyword">input</span> rst,	<span class="comment">// 复位按键(低电平有效)</span></span><br><span class="line">	<span class="keyword">input</span> [N-<span class="number">1</span>:<span class="number">0</span>] key,				<span class="comment">// 需要消抖的按键</span></span><br><span class="line">	<span class="keyword">output</span> [N-<span class="number">1</span>:<span class="number">0</span>] key_pulse	<span class="comment">// 消抖后的输出信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> N  =  <span class="number">1</span>;		<span class="comment">//要消除的按键的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] key_rst_pre;	<span class="comment">// 存储上一个触发时的按键值</span></span><br><span class="line"><span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] key_rst;			<span class="comment">// 存储当前时刻触发的按键值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [N-<span class="number">1</span>:<span class="number">0</span>] key_edge;		<span class="comment">// 检测到按键由高到低变化是产生一个高脉冲</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk  <span class="keyword">or</span>  <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!rst) <span class="keyword">begin</span></span><br><span class="line">		key_rst &lt;= &#123;N&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">		key_rst_pre &lt;= &#123;N&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		key_rst &lt;= key;</span><br><span class="line">		key_rst_pre &lt;= key_rst;</span><br><span class="line">	<span class="keyword">end</span>    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>  key_edge = key_rst_pre &amp; (~key_rst); <span class="comment">// 脉冲边沿检测。当key检测到下降沿时，key_edge产生一个时钟周期的高电平</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>	[<span class="number">17</span>:<span class="number">0</span>] cnt;			<span class="comment">// 产生延时所用的计数器，系统时钟12MHz，需要延时20ms，计数器至少18位     </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生20ms延时，当检测到 key_edge 有效时计数器清零开始计数</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!rst)</span><br><span class="line">		cnt &lt;= <span class="number">18&#x27;h0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(key_edge)</span><br><span class="line">		cnt &lt;= <span class="number">18&#x27;h0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cnt &lt;= cnt + <span class="number">1&#x27;h1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] key_sec_pre;		<span class="comment">// 延时后检测电平寄存器变量</span></span><br><span class="line"><span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] key_sec;                    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时后检测key</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk  <span class="keyword">or</span>  <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!rst)</span><br><span class="line">		key_sec &lt;= &#123;N&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (cnt==<span class="number">18&#x27;h3ffff</span>)</span><br><span class="line">		key_sec &lt;= key;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk  <span class="keyword">or</span>  <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span> (!rst)</span><br><span class="line">		key_sec_pre &lt;= &#123;N&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">	<span class="keyword">else</span>                   </span><br><span class="line">		key_sec_pre &lt;= key_sec;             </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span>  key_pulse = key_sec_pre &amp; (~key_sec);     </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 模8计数器,频率: 1KHz 计数周期: 8</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt_8;		<span class="comment">// 3位计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> cnt_8 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_1kHz)<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(cnt_8==<span class="number">3&#x27;d7</span>)</span><br><span class="line">		cnt_8&lt;=<span class="number">3&#x27;d0</span>;		<span class="comment">// 重置</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cnt_8&lt;=cnt_8+<span class="number">1</span>;	<span class="comment">// 向上计数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数码管显示"><a href="#数码管显示" class="headerlink" title="数码管显示"></a>数码管显示</h2><p>非扫描型 (共阴极)：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模块名: Display</span></span><br><span class="line"><span class="comment"> * 描述: 数码管显示模块</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> Display(</span><br><span class="line">  <span class="keyword">input</span> number,         <span class="comment">// 输入数字</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">8</span>:<span class="number">0</span>] seg, <span class="comment">// 数码管信号(共阴极数码管)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  seg &lt;= <span class="number">9&#x27;h00</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(number)<span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">case</span> (number)</span><br><span class="line">    <span class="number">0</span>: seg &lt;= <span class="number">9&#x27;h3f</span>;        <span class="comment">// 表示0</span></span><br><span class="line">    <span class="number">1</span>: seg &lt;= <span class="number">9&#x27;h06</span>;        <span class="comment">// 表示1</span></span><br><span class="line">    <span class="number">2</span>: seg &lt;= <span class="number">9&#x27;h5b</span>;        <span class="comment">// 表示2</span></span><br><span class="line">    <span class="number">3</span>: seg &lt;= <span class="number">9&#x27;h4f</span>;        <span class="comment">// 表示3</span></span><br><span class="line">    <span class="number">4</span>: seg &lt;= <span class="number">9&#x27;h66</span>;        <span class="comment">// 表示4</span></span><br><span class="line">    <span class="number">5</span>: seg &lt;= <span class="number">9&#x27;h6d</span>;        <span class="comment">// 表示5</span></span><br><span class="line">    <span class="number">6</span>: seg &lt;= <span class="number">9&#x27;h7d</span>;        <span class="comment">// 表示6</span></span><br><span class="line">    <span class="number">7</span>: seg &lt;= <span class="number">9&#x27;h07</span>;        <span class="comment">// 表示7</span></span><br><span class="line">    <span class="number">8</span>: seg &lt;= <span class="number">9&#x27;h7f</span>;        <span class="comment">// 表示8</span></span><br><span class="line">    <span class="keyword">default</span>: seg &lt;= <span class="number">9&#x27;h6f</span>;  <span class="comment">// 表示9</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扫描型 (共阴极)：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模块名: Display</span></span><br><span class="line"><span class="comment"> * 描述: 数码管显示模块</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> Display(</span><br><span class="line">  <span class="keyword">input</span> clk_1kHz,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] tens,</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] ones,</span><br><span class="line">  ……</span><br><span class="line">  <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] xxxx,</span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] seg, <span class="comment">// 数码管阳极信号</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] cat <span class="comment">// 数码管阴极信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  seg &lt;= <span class="number">8&#x27;b0000_0000</span>;</span><br><span class="line">  cat &lt;= <span class="number">8&#x27;b1111_1111</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(cnt_8) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">case</span> (cnt_8)</span><br><span class="line">    <span class="comment">/* 个位 */</span></span><br><span class="line">    <span class="number">0</span>: <span class="keyword">begin</span></span><br><span class="line">      cat&lt;=<span class="number">8&#x27;b1111_1110</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (ones)</span><br><span class="line">        <span class="number">0</span>: seg&lt;=<span class="number">8&#x27;b0011_1111</span>;</span><br><span class="line">        <span class="number">1</span>: seg&lt;=<span class="number">8&#x27;b0000_0110</span>;</span><br><span class="line">        <span class="number">2</span>: seg&lt;=<span class="number">8&#x27;b0101_1011</span>;</span><br><span class="line">        <span class="number">3</span>: seg&lt;=<span class="number">8&#x27;b0100_1111</span>;</span><br><span class="line">        <span class="number">4</span>: seg&lt;=<span class="number">8&#x27;b0110_0110</span>;</span><br><span class="line">        <span class="number">5</span>: seg&lt;=<span class="number">8&#x27;b0110_1101</span>;</span><br><span class="line">        <span class="number">6</span>: seg&lt;=<span class="number">8&#x27;b0111_1101</span>;</span><br><span class="line">        <span class="number">7</span>: seg&lt;=<span class="number">8&#x27;b0000_0111</span>;</span><br><span class="line">        <span class="number">8</span>: seg&lt;=<span class="number">8&#x27;b0111_1111</span>;</span><br><span class="line">        <span class="keyword">default</span>: seg&lt;=<span class="number">8&#x27;b0110_1111</span>;</span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">/* 十位 */</span></span><br><span class="line">    <span class="number">1</span>: <span class="keyword">begin</span></span><br><span class="line">      cat&lt;=<span class="number">8&#x27;b1111_1101</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (ones)</span><br><span class="line">        <span class="number">0</span>: seg&lt;=<span class="number">8&#x27;b0011_1111</span>;</span><br><span class="line">        <span class="number">1</span>: seg&lt;=<span class="number">8&#x27;b0000_0110</span>;</span><br><span class="line">        <span class="number">2</span>: seg&lt;=<span class="number">8&#x27;b0101_1011</span>;</span><br><span class="line">        <span class="number">3</span>: seg&lt;=<span class="number">8&#x27;b0100_1111</span>;</span><br><span class="line">        <span class="number">4</span>: seg&lt;=<span class="number">8&#x27;b0110_0110</span>;</span><br><span class="line">        <span class="number">5</span>: seg&lt;=<span class="number">8&#x27;b0110_1101</span>;</span><br><span class="line">        <span class="number">6</span>: seg&lt;=<span class="number">8&#x27;b0111_1101</span>;</span><br><span class="line">        <span class="number">7</span>: seg&lt;=<span class="number">8&#x27;b0000_0111</span>;</span><br><span class="line">        <span class="number">8</span>: seg&lt;=<span class="number">8&#x27;b0111_1111</span>;</span><br><span class="line">        <span class="keyword">default</span>: seg&lt;=<span class="number">8&#x27;b0110_1111</span>;</span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">      cat&lt;=<span class="number">8&#x27;b0111_1111</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> (xxxx)</span><br><span class="line">        <span class="number">0</span>: seg&lt;=<span class="number">8&#x27;b0011_1111</span>;</span><br><span class="line">        <span class="number">1</span>: seg&lt;=<span class="number">8&#x27;b0000_0110</span>;</span><br><span class="line">        <span class="number">2</span>: seg&lt;=<span class="number">8&#x27;b0101_1011</span>;</span><br><span class="line">        <span class="number">3</span>: seg&lt;=<span class="number">8&#x27;b0100_1111</span>;</span><br><span class="line">        <span class="number">4</span>: seg&lt;=<span class="number">8&#x27;b0110_0110</span>;</span><br><span class="line">        <span class="number">5</span>: seg&lt;=<span class="number">8&#x27;b0110_1101</span>;</span><br><span class="line">        <span class="number">6</span>: seg&lt;=<span class="number">8&#x27;b0111_1101</span>;</span><br><span class="line">        <span class="number">7</span>: seg&lt;=<span class="number">8&#x27;b0000_0111</span>;</span><br><span class="line">        <span class="number">8</span>: seg&lt;=<span class="number">8&#x27;b0111_1111</span>;</span><br><span class="line">        <span class="keyword">default</span>: seg&lt;=<span class="number">8&#x27;b0110_1111</span>;</span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 模8计数器,频率: 1KHz 计数周期: 8</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt_8;		<span class="comment">// 3位计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> cnt_8 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_1kHz)<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(cnt_8==<span class="number">3&#x27;d7</span>)</span><br><span class="line">		cnt_8&lt;=<span class="number">3&#x27;d0</span>;		<span class="comment">// 重置</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cnt_8&lt;=cnt_8+<span class="number">1</span>;	<span class="comment">// 向上计数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="点阵显示"><a href="#点阵显示" class="headerlink" title="点阵显示"></a>点阵显示</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模块名: Lattice_Display</span></span><br><span class="line"><span class="comment"> * 描述: 点阵显示模块</span></span><br><span class="line"><span class="comment"> * 输入: 1kHz时钟</span></span><br><span class="line"><span class="comment"> * 输出: 行信号, 红列信号, 绿列信号</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> Lattice_Display(</span><br><span class="line">	<span class="keyword">input</span> clk_1kHz,		<span class="comment">// 1KHz时钟</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] row,				<span class="comment">// 行信号(低电平有效)</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] col_r,			<span class="comment">// 红色列信号(高电平有效)</span></span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] col_g			<span class="comment">// 绿色列信号(高电平有效)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(cnt_8)<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">case</span>(cnt_8)</span><br><span class="line">		<span class="number">3&#x27;d7</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b0111_1111</span>;col_r&lt;=<span class="number">8&#x27;b0000_0011</span>;col_g&lt;=<span class="number">8&#x27;b0000_0000</span>;<span class="keyword">end</span>		<span class="comment">// 第 7 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d6</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1011_1111</span>;col_r&lt;=<span class="number">8&#x27;b0000_0011</span>;col_g&lt;=<span class="number">8&#x27;b0000_0000</span>;<span class="keyword">end</span>		<span class="comment">// 第 6 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d5</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1101_1111</span>;col_r&lt;=<span class="number">8&#x27;b0000_0000</span>;col_g&lt;=<span class="number">8&#x27;b0000_0000</span>;<span class="keyword">end</span>		<span class="comment">// 第 5 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d4</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1110_1111</span>;col_r&lt;=<span class="number">8&#x27;b0000_0000</span>;col_g&lt;=<span class="number">8&#x27;b0000_0011</span>;<span class="keyword">end</span>		<span class="comment">// 第 4 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d3</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1111_0111</span>;col_r&lt;=<span class="number">8&#x27;b0000_0000</span>;col_g&lt;=<span class="number">8&#x27;b0000_0011</span>;<span class="keyword">end</span>		<span class="comment">// 第 3 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d2</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1111_1011</span>;col_r&lt;=<span class="number">8&#x27;b0000_0000</span>;col_g&lt;=<span class="number">8&#x27;b0000_0000</span>;<span class="keyword">end</span>		<span class="comment">// 第 2 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d1</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1111_1101</span>;col_r&lt;=<span class="number">8&#x27;b0000_0011</span>;col_g&lt;=<span class="number">8&#x27;b0000_0011</span>;<span class="keyword">end</span>		<span class="comment">// 第 1 行显示</span></span><br><span class="line">		<span class="number">3&#x27;d0</span>:<span class="keyword">begin</span> row=<span class="number">8&#x27;b1111_1110</span>;col_r&lt;=<span class="number">8&#x27;b0000_0011</span>;col_g&lt;=<span class="number">8&#x27;b0000_0011</span>;<span class="keyword">end</span>		<span class="comment">// 第 0 行显示</span></span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 模8计数器,频率: 1KHz 计数周期: 8</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt_8;		<span class="comment">// 3位计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> cnt_8 &lt;= <span class="number">3&#x27;d0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_1kHz)<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(cnt_8==<span class="number">3&#x27;d7</span>)</span><br><span class="line">		cnt_8&lt;=<span class="number">3&#x27;d0</span>;		<span class="comment">// 重置</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cnt_8&lt;=cnt_8+<span class="number">1</span>;	<span class="comment">// 向上计数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h2><ul>
<li>音调调配：</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块名: Beeper</span></span><br><span class="line"><span class="comment"> * 描述: 蜂鸣器输出模块</span></span><br><span class="line"><span class="comment"> * 输入: 10MHz时钟, 使能信号, 音节控制</span></span><br><span class="line"><span class="comment"> * 输出: 蜂鸣器输出控制</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">module</span> Beeper</span><br><span class="line">(</span><br><span class="line"><span class="keyword">input</span> clk_10MHz,			<span class="comment">// 10MHz时钟</span></span><br><span class="line"><span class="keyword">input</span> tone_en,				<span class="comment">// 蜂鸣器使能信号(高电平有效)</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] tone,			<span class="comment">// 蜂鸣器音节控制</span></span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> piano_out	<span class="comment">// 蜂鸣器控制输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] time_end;	<span class="comment">// 计数器最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@(tone) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">case</span>(tone)</span><br><span class="line">		<span class="number">5&#x27;d1</span>:	time_end =	  <span class="number">16&#x27;d19110</span>;	<span class="comment">//L1,</span></span><br><span class="line">		<span class="number">5&#x27;d2</span>:	time_end =	  <span class="number">16&#x27;d17026</span>;	<span class="comment">//L2,</span></span><br><span class="line">		<span class="number">5&#x27;d3</span>:	time_end =	  <span class="number">16&#x27;d15169</span>;	<span class="comment">//L3,</span></span><br><span class="line">		<span class="number">5&#x27;d4</span>:	time_end =	  <span class="number">16&#x27;d14317</span>;	<span class="comment">//L4,</span></span><br><span class="line">		<span class="number">5&#x27;d5</span>:	time_end =	  <span class="number">16&#x27;d12755</span>;	<span class="comment">//L5,</span></span><br><span class="line">		<span class="number">5&#x27;d6</span>:	time_end =	  <span class="number">16&#x27;d11363</span>;	<span class="comment">//L6,</span></span><br><span class="line">		<span class="number">5&#x27;d7</span>:	time_end =	  <span class="number">16&#x27;d10124</span>;	<span class="comment">//L7,</span></span><br><span class="line"></span><br><span class="line">		<span class="number">5&#x27;d8</span>:	time_end =	  <span class="number">16&#x27;d9556</span>;	<span class="comment">//M1,</span></span><br><span class="line">		<span class="number">5&#x27;d9</span>:	time_end =	  <span class="number">16&#x27;d8513</span>;	<span class="comment">//M2,</span></span><br><span class="line">		<span class="number">5&#x27;d10</span>:	time_end =	<span class="number">16&#x27;d7584</span>;	<span class="comment">//M3,</span></span><br><span class="line">		<span class="number">5&#x27;d11</span>:	time_end =	<span class="number">16&#x27;d7159</span>;	<span class="comment">//M4,</span></span><br><span class="line">		<span class="number">5&#x27;d12</span>:	time_end =	<span class="number">16&#x27;d6378</span>;	<span class="comment">//M5,</span></span><br><span class="line">		<span class="number">5&#x27;d13</span>:	time_end =	<span class="number">16&#x27;d5682</span>;	<span class="comment">//M6,</span></span><br><span class="line">		<span class="number">5&#x27;d14</span>:	time_end =	<span class="number">16&#x27;d5062</span>;	<span class="comment">//M7,</span></span><br><span class="line"></span><br><span class="line">		<span class="number">5&#x27;d15</span>:	time_end =	<span class="number">16&#x27;d4782</span>;	<span class="comment">//H1,</span></span><br><span class="line">		<span class="number">5&#x27;d16</span>:	time_end =	<span class="number">16&#x27;d4257</span>;	<span class="comment">//H2,</span></span><br><span class="line">		<span class="number">5&#x27;d17</span>:	time_end =	<span class="number">16&#x27;d3792</span>;	<span class="comment">//H3,</span></span><br><span class="line">		<span class="number">5&#x27;d18</span>:	time_end =	<span class="number">16&#x27;d3579</span>;	<span class="comment">//H4,</span></span><br><span class="line">		<span class="number">5&#x27;d19</span>:	time_end =	<span class="number">16&#x27;d3189</span>;	<span class="comment">//H5,</span></span><br><span class="line">		<span class="number">5&#x27;d20</span>:	time_end =	<span class="number">16&#x27;d2841</span>;	<span class="comment">//H6,</span></span><br><span class="line">		<span class="number">5&#x27;d21</span>:	time_end =	<span class="number">16&#x27;d2531</span>;	<span class="comment">//H7,</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:time_end =	<span class="number">16&#x27;d65535</span>;	</span><br><span class="line">	<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">17</span>:<span class="number">0</span>] time_cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模 time_end 计数器</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_10MHz) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(!tone_en) <span class="keyword">begin</span></span><br><span class="line">		time_cnt &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">// 始终保持0</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(time_cnt &gt;= time_end) <span class="keyword">begin</span></span><br><span class="line">		time_cnt &lt;= <span class="number">1&#x27;b0</span>;	<span class="comment">// 重置</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		time_cnt &lt;= time_cnt + <span class="number">1&#x27;b1</span>;	<span class="comment">// 向上计数</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据计数器的周期，翻转蜂鸣器控制信号</span></span><br><span class="line"><span class="keyword">always</span>@(<span class="keyword">posedge</span> clk_10MHz) <span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">if</span>(time_cnt == time_end) <span class="keyword">begin</span></span><br><span class="line">		piano_out &lt;= ~piano_out;		<span class="comment">// 翻转</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">		piano_out &lt;= piano_out;			<span class="comment">// 保持</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32标准库学习</title>
    <url>/posts/20930.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="stm32-固件库函数介绍"><a href="#stm32-固件库函数介绍" class="headerlink" title="stm32 固件库函数介绍"></a>stm32 固件库函数介绍</h1><p><strong>1、RCC</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHBPeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHBPeriph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB2PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB2Periph, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_APB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_APB1Periph, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2、GPIO 相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_AFIODeInit</span><span class="params">(<span class="type">void</span>)</span>;							<span class="comment">// 复位AFIO外设</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinLockConfig</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span>;		<span class="comment">// 锁定 GPIO 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;	<span class="comment">// 配置AFIO事件输出功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EventOutputCmd</span><span class="params">(FunctionalState NewState)</span>;				<span class="comment">// 配置AFIO事件输出功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_PinRemapConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_Remap, FunctionalState NewState)</span>;	<span class="comment">// 进行引脚重映射</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_EXTILineConfig</span><span class="params">(<span class="type">uint8_t</span> GPIO_PortSource, <span class="type">uint8_t</span> GPIO_PinSource)</span>;	<span class="comment">// 配置AFIO的数据选择器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_ETH_MediaInterfaceConfig</span><span class="params">(<span class="type">uint32_t</span> GPIO_ETH_MediaInterface)</span>;		<span class="comment">// 与以太网有关</span></span><br></pre></td></tr></table></figure>

<p><strong>3、EXTI 相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI_DeInit</span><span class="params">(<span class="type">void</span>)</span>;					<span class="comment">// 清除 EXTI 配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;	<span class="comment">// 初始化 EXTI</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_StructInit</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;<span class="comment">// 给EXTI结构体赋默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_GenerateSWInterrupt</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;	<span class="comment">// 软件触发EXTI外部中断</span></span><br><span class="line">FlagStatus <span class="title function_">EXTI_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;	<span class="comment">// 获取标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;		<span class="comment">// 清空标志位</span></span><br><span class="line">ITStatus <span class="title function_">EXTI_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;		<span class="comment">// 获取中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> EXTI_Line)</span>;	<span class="comment">// 清空中断标志位</span></span><br></pre></td></tr></table></figure>

<p><strong>4、中断向量表</strong></p>
<p>中断向量表位于启动文件（start&#x2F;startup_stm32f10x.md.s）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     SVC_Handler                ; SVCall Handler</span><br><span class="line">                DCD     DebugMon_Handler           ; Debug Monitor Handler</span><br><span class="line">                DCD     <span class="number">0</span>                          ; Reserved</span><br><span class="line">                DCD     PendSV_Handler             ; PendSV Handler</span><br><span class="line">                DCD     SysTick_Handler            ; SysTick Handler</span><br><span class="line"></span><br><span class="line">                ; External Interrupts</span><br><span class="line">                DCD     WWDG_IRQHandler            ; Window Watchdog</span><br><span class="line">                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect</span><br><span class="line">                DCD     TAMPER_IRQHandler          ; Tamper</span><br><span class="line">                DCD     RTC_IRQHandler             ; RTC</span><br><span class="line">                DCD     FLASH_IRQHandler           ; Flash</span><br><span class="line">                DCD     RCC_IRQHandler             ; RCC</span><br><span class="line">                DCD     EXTI0_IRQHandler           ; EXTI Line <span class="number">0</span></span><br><span class="line">                DCD     EXTI1_IRQHandler           ; EXTI Line <span class="number">1</span></span><br><span class="line">                DCD     EXTI2_IRQHandler           ; EXTI Line <span class="number">2</span></span><br><span class="line">                DCD     EXTI3_IRQHandler           ; EXTI Line <span class="number">3</span></span><br><span class="line">                DCD     EXTI4_IRQHandler           ; EXTI Line <span class="number">4</span></span><br><span class="line">                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel <span class="number">1</span></span><br><span class="line">                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel <span class="number">2</span></span><br><span class="line">                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel <span class="number">3</span></span><br><span class="line">                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel <span class="number">4</span></span><br><span class="line">                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel <span class="number">5</span></span><br><span class="line">                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel <span class="number">6</span></span><br><span class="line">                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel <span class="number">7</span></span><br><span class="line">                DCD     ADC1_2_IRQHandler          ; ADC1_2</span><br><span class="line">                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX</span><br><span class="line">                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0</span><br><span class="line">                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1</span><br><span class="line">                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE</span><br><span class="line">                DCD     EXTI9_5_IRQHandler         ; EXTI Line <span class="number">9.</span><span class="number">.5</span></span><br><span class="line">                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break</span><br><span class="line">                DCD     TIM1_UP_IRQHandler         ; TIM1 Update</span><br><span class="line">                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation</span><br><span class="line">                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare</span><br><span class="line">                DCD     TIM2_IRQHandler            ; TIM2</span><br><span class="line">                DCD     TIM3_IRQHandler            ; TIM3</span><br><span class="line">                DCD     TIM4_IRQHandler            ; TIM4</span><br><span class="line">                DCD     I2C1_EV_IRQHandler         ; I2C1 Event</span><br><span class="line">                DCD     I2C1_ER_IRQHandler         ; I2C1 Error</span><br><span class="line">                DCD     I2C2_EV_IRQHandler         ; I2C2 Event</span><br><span class="line">                DCD     I2C2_ER_IRQHandler         ; I2C2 Error</span><br><span class="line">                DCD     SPI1_IRQHandler            ; SPI1</span><br><span class="line">                DCD     SPI2_IRQHandler            ; SPI2</span><br><span class="line">                DCD     USART1_IRQHandler          ; USART1</span><br><span class="line">                DCD     USART2_IRQHandler          ; USART2</span><br><span class="line">                DCD     USART3_IRQHandler          ; USART3</span><br><span class="line">                DCD     EXTI15_10_IRQHandler       ; EXTI Line <span class="number">15.</span><span class="number">.10</span></span><br><span class="line">                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line</span><br><span class="line">                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend</span><br><span class="line">__Vectors_End</span><br></pre></td></tr></table></figure>

<p><strong>5、NVIC 相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 注意：中断分支整个项目只能进行一次 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span>;				<span class="comment">// 中断分组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span>;					<span class="comment">// 初始化 NVIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SetVectorTable</span><span class="params">(<span class="type">uint32_t</span> NVIC_VectTab, <span class="type">uint32_t</span> Offset)</span>;			<span class="comment">// 设置中断向量表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_SystemLPConfig</span><span class="params">(<span class="type">uint8_t</span> LowPowerMode, FunctionalState NewState)</span>;		<span class="comment">// 系统低功耗配置</span></span><br></pre></td></tr></table></figure>

<p><strong>6、TIM 相关函数</strong></p>
<p>基本函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_DeInit</span><span class="params">(TIM_TypeDef* TIMx)</span>;								<span class="comment">// 恢复缺省配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;	<span class="comment">// 时基单元初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TimeBaseStructInit</span><span class="params">(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span>;			<span class="comment">// 时基单元结构体变量赋默认值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;					<span class="comment">// 使能计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT, FunctionalState NewState)</span>;		<span class="comment">// 使能中断输出信号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_InternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx)</span>;						<span class="comment">// 选择内部时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ITRxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;		<span class="comment">// 选择其他定时器的时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_TIxExternalClockConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TIxExternalCLKSource,</span></span><br><span class="line"><span class="params">                                <span class="type">uint16_t</span> TIM_ICPolarity, <span class="type">uint16_t</span> ICFilter)</span>;			<span class="comment">// 选择TIx捕获通道的时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,</span></span><br><span class="line"><span class="params">                             <span class="type">uint16_t</span> ExtTRGFilter)</span>;						<span class="comment">// 选择 ETR 通过外部时钟模式1输入的时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRClockMode2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, </span></span><br><span class="line"><span class="params">                             <span class="type">uint16_t</span> TIM_ExtTRGPolarity, <span class="type">uint16_t</span> ExtTRGFilter)</span>;		<span class="comment">// 选择 ETR 通过外部时钟模式2输入的时钟</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ETRConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ExtTRGPrescaler, <span class="type">uint16_t</span> TIM_ExtTRGPolarity,</span></span><br><span class="line"><span class="params">                   <span class="type">uint16_t</span> ExtTRGFilter)</span>;							<span class="comment">// 配置 ETR 预分频器、极性、滤波器等参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更改参数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PrescalerConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Prescaler, <span class="type">uint16_t</span> TIM_PSCReloadMode)</span>;	<span class="comment">// 更改预分频值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CounterModeConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CounterMode)</span>;			<span class="comment">// 改变计数模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;				<span class="comment">// 改变计数器的预装功能设置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCounter</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Counter)</span>;					<span class="comment">// 给计数器写入值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetAutoreload</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Autoreload)</span>;					<span class="comment">// 给自动重装器写入值</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCounter</span><span class="params">(TIM_TypeDef* TIMx)</span>;							<span class="comment">// 获取当前计数器的值</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetPrescaler</span><span class="params">(TIM_TypeDef* TIMx)</span>;							<span class="comment">// 获取当前预分频的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取与清除标志位 */</span></span><br><span class="line">FlagStatus <span class="title function_">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;	<span class="comment">// 获取标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_FLAG)</span>;		<span class="comment">// 清空标志位</span></span><br><span class="line">ITStatus <span class="title function_">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;		<span class="comment">// 获取中断标志位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_IT)</span>;		<span class="comment">// 清空中断标志位</span></span><br></pre></td></tr></table></figure>

<p>输出比较函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;	<span class="comment">// 配置输出比较模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;	<span class="comment">// 配置输出比较模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;	<span class="comment">// 配置输出比较模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4Init</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;	<span class="comment">// 配置输出比较模块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OCStructInit</span><span class="params">(TIM_OCInitTypeDef* TIM_OCInitStruct)</span>;			<span class="comment">// 输出结构体赋默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC1Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;		<span class="comment">// 配置强制输出模式，强制输出高电平或低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC2Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;		<span class="comment">// 配置强制输出模式，强制输出高电平或低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC3Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;		<span class="comment">// 配置强制输出模式，强制输出高电平或低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ForcedOC4Config</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ForcedAction)</span>;		<span class="comment">// 配置强制输出模式，强制输出高电平或低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;		<span class="comment">// 配置 CCR 预装值功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;		<span class="comment">// 配置 CCR 预装值功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;		<span class="comment">// 配置 CCR 预装值功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;		<span class="comment">// 配置 CCR 预装值功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;			<span class="comment">// 配置快速使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;			<span class="comment">// 配置快速使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;			<span class="comment">// 配置快速使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4FastConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCFast)</span>;			<span class="comment">// 配置快速使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC1Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;			<span class="comment">// 外部事件时清除 REF 信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC2Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;			<span class="comment">// 外部事件时清除 REF 信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC3Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;			<span class="comment">// 外部事件时清除 REF 信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ClearOC4Ref</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCClear)</span>;			<span class="comment">// 外部事件时清除 REF 信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;		<span class="comment">// 设置输出比较的极性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC1NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;	<span class="comment">// 设置输出比较的极性（互补通道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;		<span class="comment">// 设置输出比较的极性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC2NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;	<span class="comment">// 设置输出比较的极性（互补通道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;		<span class="comment">// 设置输出比较的极性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC3NPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCNPolarity)</span>;	<span class="comment">// 设置输出比较的极性（互补通道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_OC4PolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPolarity)</span>;		<span class="comment">// 设置输出比较的极性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCx)</span>;	<span class="comment">// 修改输出使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_CCxNCmd</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_CCxN)</span>;	<span class="comment">// 修改输出使能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOCxM</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_Channel, <span class="type">uint16_t</span> TIM_OCMode)</span>;<span class="comment">// 修改输出比较模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare1</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare1)</span>;			<span class="comment">// 更改 CCR 寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare2</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare2)</span>;			<span class="comment">// 更改 CCR 寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare3</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare3)</span>;			<span class="comment">// 更改 CCR 寄存器的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetCompare4</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> Compare4)</span>;			<span class="comment">// 更改 CCR 寄存器的值</span></span><br></pre></td></tr></table></figure>

<p>输入捕获函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;	<span class="comment">// 输入捕获单元初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_PWMIConfig</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;	<span class="comment">// 初始化输入捕获单元，快速配置两个通道，配置为PWMI模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_ICStructInit</span><span class="params">(TIM_ICInitTypeDef* TIM_ICInitStruct)</span>;<span class="comment">// 输入捕获结构体赋默认值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectInputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_InputTriggerSource)</span>;	<span class="comment">// 选择输入触发源（从模式的触发源）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectOutputTrigger</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_TRGOSource)</span>;	<span class="comment">// 选择输出触发源TRGO（主模式输出）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SelectSlaveMode</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_SlaveMode)</span>;	<span class="comment">// 选择从模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC1Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;	<span class="comment">// 配置1通道的分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC2Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;	<span class="comment">// 配置2通道的分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC3Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;	<span class="comment">// 配置3通道的分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetIC4Prescaler</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_ICPSC)</span>;	<span class="comment">// 配置4通道的分频器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM_SetClockDivision</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_CKD)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span>;	<span class="comment">// 读取1通道的CCR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture2</span><span class="params">(TIM_TypeDef* TIMx)</span>;	<span class="comment">// 读取2通道的CCR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture3</span><span class="params">(TIM_TypeDef* TIMx)</span>;	<span class="comment">// 读取3通道的CCR</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">TIM_GetCapture4</span><span class="params">(TIM_TypeDef* TIMx)</span>;	<span class="comment">// 读取4通道的CCR</span></span><br></pre></td></tr></table></figure>

<p>编码器接口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM_EncoderInterfaceConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_EncoderMode,</span></span><br><span class="line"><span class="params">                                <span class="type">uint16_t</span> TIM_IC1Polarity, <span class="type">uint16_t</span> TIM_IC2Polarity)</span>;	<span class="comment">// 编码器接口配置</span></span><br></pre></td></tr></table></figure>

<p><strong>7、ADC相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_ADCCLKConfig</span><span class="params">(<span class="type">uint32_t</span> RCC_PCLK2)</span>;	<span class="comment">// 配置 ADC_CLK 分频器</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ADC_DeInit</span><span class="params">(ADC_TypeDef* ADCx)</span>;							<span class="comment">// 恢复缺省配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Init</span><span class="params">(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)</span>;			<span class="comment">// 初始化 ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StructInit</span><span class="params">(ADC_InitTypeDef* ADC_InitStruct)</span>;					<span class="comment">// ADC结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_Cmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;				<span class="comment">// 开启 ADC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DMACmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;				<span class="comment">// 开启 DMA 输出信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ITConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT, FunctionalState NewState)</span>;	<span class="comment">// 中断输出控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;		<span class="comment">// 软件触发 ADC</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartConvStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;				<span class="comment">// 获取软件开始转换状态（软件触发后立刻从1清零）（一般不用）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeChannelCountConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Number)</span>;			<span class="comment">// 配置每隔几个通道间断一次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_DiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;			<span class="comment">// 启用间断模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_RegularChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;	<span class="comment">// ADC规则组通道配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;		<span class="comment">// ADC 外部触发转换控制</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetConversionValue</span><span class="params">(ADC_TypeDef* ADCx)</span>;					<span class="comment">// ADC 获取转换值</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ADC_GetDualModeConversionValue</span><span class="params">(<span class="type">void</span>)</span>;						<span class="comment">// ADC 获取双模式转换值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 校准相关配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ResetCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;			<span class="comment">// 复位校准</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetResetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;	<span class="comment">// 获取复位校准状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_StartCalibration</span><span class="params">(ADC_TypeDef* ADCx)</span>;			<span class="comment">// 开始校准</span></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetCalibrationStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;		<span class="comment">// 获取开始校准状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注入组相关配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AutoInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedDiscModeCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_ExternalTrigInjecConv)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ExternalTrigInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SoftwareStartInjectedConvCmd</span><span class="params">(ADC_TypeDef* ADCx, FunctionalState NewState)</span>;</span><br><span class="line">FlagStatus <span class="title function_">ADC_GetSoftwareStartInjectedConvCmdStatus</span><span class="params">(ADC_TypeDef* ADCx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel, <span class="type">uint8_t</span> Rank, <span class="type">uint8_t</span> ADC_SampleTime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_InjectedSequencerLengthConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> Length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_SetInjectedOffset</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel, <span class="type">uint16_t</span> Offset)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ADC_GetInjectedConversionValue</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_InjectedChannel)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模拟看门狗相关配置 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogCmd</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint32_t</span> ADC_AnalogWatchdog)</span>;					<span class="comment">// 是否启动模拟看门狗</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogThresholdsConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> HighThreshold, <span class="type">uint16_t</span> LowThreshold)</span>;	<span class="comment">// 配置高低阈值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_AnalogWatchdogSingleChannelConfig</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_Channel)</span>;				<span class="comment">// 配置看门通道</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_TempSensorVrefintCmd</span><span class="params">(FunctionalState NewState)</span>;		<span class="comment">// ADC 温度传感器，内部电压控制</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">ADC_GetFlagStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;	<span class="comment">// 获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearFlag</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint8_t</span> ADC_FLAG)</span>;		<span class="comment">// 清空标志位</span></span><br><span class="line">ITStatus <span class="title function_">ADC_GetITStatus</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;		<span class="comment">// 获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ADC_ClearITPendingBit</span><span class="params">(ADC_TypeDef* ADCx, <span class="type">uint16_t</span> ADC_IT)</span>;		<span class="comment">// 清空中断挂起位</span></span><br></pre></td></tr></table></figure>

<p><strong>8、DMA 相关函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DMA_DeInit</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;							<span class="comment">// 恢复缺省配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span>;			<span class="comment">// 初始化 DMA</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_StructInit</span><span class="params">(DMA_InitTypeDef* DMA_InitStruct)</span>;							<span class="comment">// DMA 结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_Cmd</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</span>;				<span class="comment">// 使能 DMA</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ITConfig</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint32_t</span> DMA_IT, FunctionalState NewState)</span>;	<span class="comment">// 中断输出使能</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_SetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, <span class="type">uint16_t</span> DataNumber)</span>;	<span class="comment">// DMA 设置当前数据寄存器</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">DMA_GetCurrDataCounter</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx)</span>;			<span class="comment">// DMA 获取当前数据寄存器</span></span><br><span class="line"></span><br><span class="line">FlagStatus <span class="title function_">DMA_GetFlagStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;	<span class="comment">// 获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearFlag</span><span class="params">(<span class="type">uint32_t</span> DMAy_FLAG)</span>;			<span class="comment">// 清空标志位</span></span><br><span class="line">ITStatus <span class="title function_">DMA_GetITStatus</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;		<span class="comment">// 获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_ClearITPendingBit</span><span class="params">(<span class="type">uint32_t</span> DMAy_IT)</span>;		<span class="comment">// 清空中断挂起位</span></span><br></pre></td></tr></table></figure>

<p><strong>9、USART</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART_DeInit</span><span class="params">(USART_TypeDef* USARTx)</span>;							<span class="comment">// 恢复缺省配置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Init</span><span class="params">(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)</span>;			<span class="comment">// 初始化 USART</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_StructInit</span><span class="params">(USART_InitTypeDef* USART_InitStruct)</span>;					<span class="comment">// USART 结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockInit</span><span class="params">(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;	<span class="comment">// 配置同步时钟输出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClockStructInit</span><span class="params">(USART_ClockInitTypeDef* USART_ClockInitStruct)</span>;			<span class="comment">// 同步时钟输出结构体初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_Cmd</span><span class="params">(USART_TypeDef* USARTx, FunctionalState NewState)</span>;				<span class="comment">// 开启 USART</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ITConfig</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT, FunctionalState NewState)</span>;	<span class="comment">// 开启中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_DMACmd</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_DMAReq, FunctionalState NewState)</span>;	<span class="comment">// 开启USART到DMA的触发通道</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_SendData</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> Data)</span>;		<span class="comment">// 发送数据</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">USART_ReceiveData</span><span class="params">(USART_TypeDef* USARTx)</span>;			<span class="comment">// 接收数据</span></span><br><span class="line">FlagStatus <span class="title function_">USART_GetFlagStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;	<span class="comment">// 获取标志位状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearFlag</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_FLAG)</span>;		<span class="comment">// 清空标志位</span></span><br><span class="line">ITStatus <span class="title function_">USART_GetITStatus</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;		<span class="comment">// 获取中断状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART_ClearITPendingBit</span><span class="params">(USART_TypeDef* USARTx, <span class="type">uint16_t</span> USART_IT)</span>;		<span class="comment">// 清空中断挂起位</span></span><br></pre></td></tr></table></figure>

<h1 id="基础模块设计"><a href="#基础模块设计" class="headerlink" title="基础模块设计"></a>基础模块设计</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><p>具体步骤</p>
<ul>
<li>RCC 开启时钟</li>
<li>GPIO_Init() 初始化 GPIO</li>
<li>使用输出或输入函数控制 GPIO</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		<span class="comment">//GPIO_Pin_15;</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>

<h2 id="EXTI-外部中断"><a href="#EXTI-外部中断" class="headerlink" title="EXTI 外部中断"></a>EXTI 外部中断</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/EXTI.jpg" alt="EXTI基本结构" title="EXTI基本结构"></p>
<p>具体步骤</p>
<ul>
<li>RCC 开启时钟（GPIO、AFIO）</li>
<li>配置 GPIO 为输入模式</li>
<li>配置 AFIO，选择我们使用的一路GPIO</li>
<li>配置 EXTI，选择边沿触发方式、触发响应方式（中断响应、事件响应）</li>
<li>配置 NVIC，选择优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 GPIO  */</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 AFIO */</span></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource14);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 EXTI */</span></span><br><span class="line">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line14;</span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 NVIC，中断分组 */</span></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 配置 NVIC，设置优先级 */</span></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line14) == SET)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		EXTI_ClearITPendingBit(EXTI_Line14);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>EXTI 与 NVIC 的时钟不需手动开启</p>
</blockquote>
<h2 id="Timer-定时中断"><a href="#Timer-定时中断" class="headerlink" title="Timer 定时中断"></a>Timer 定时中断</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/Timed_interrupt.jpg" alt="定时中断基本结构" title="定时中断基本结构"></p>
<ul>
<li><p>具体步骤</p>
<ul>
<li>RCC 开启时钟</li>
<li>选择时基单元的时钟源（定时中断选择内部时钟源）</li>
<li>配置时基单元</li>
<li>配置输出中断控制，允许更新中断到 NVIC</li>
<li>配置 NVIC，打开定时器中断通道，分配优先级</li>
<li>运行控制</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 选择时基单元的时钟源，内部时钟源 */</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 配置时基单元 */</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">	TIM_ClearFlag(TIM2, TIM_FLAG_Update);</span><br><span class="line">	TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);		<span class="comment">// 使能中断</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 配置 NVIC，中断分组 */</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 配置 NVIC，配置优先级 */</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 启动计时器 */</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PWM-输出"><a href="#PWM-输出" class="headerlink" title="PWM 输出"></a>PWM 输出</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/IC.jpg" alt="PWM基本结构" title="PWM基本结构"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟</li>
<li>配置时基单元</li>
<li>配置输出比较单元</li>
<li>配置 GPIO</li>
<li>运行控制，启动计数器</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 配置 GPIO */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 选择时基单元的时钟源，内部时钟源 */</span></span><br><span class="line">	TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 配置时基单元 */</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">36</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 配置输出比较单元 */</span></span><br><span class="line">	TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">	TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">	TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;		<span class="comment">//CCR</span></span><br><span class="line">	TIM_OC3Init(TIM2, &amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 运行控制，启动计数器 */</span></span><br><span class="line">	TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置占空比</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare3</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_SetCompare3(TIM2, Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置预分频值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetPrescaler</span><span class="params">(<span class="type">uint16_t</span> Prescaler)</span></span><br><span class="line">&#123;</span><br><span class="line">	TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="IC-输入捕获"><a href="#IC-输入捕获" class="headerlink" title="IC 输入捕获"></a>IC 输入捕获</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/Snipaste_2023-04-02_22-01-01.png" alt="Snipaste_2023-04-02_22-01-01"></p>
<p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/PWMI.jpg" alt="主从触发模式" title="主从触发模式"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟</li>
<li>GPIO 初始化为输入模式（上拉或浮空）</li>
<li>配置时基单元</li>
<li>配置输入捕获单元，包括滤波器、极性、直连通道还是交叉通道、分频器这些参数</li>
<li>选择从模式的触发源（TI1FP1）</li>
<li>选择触发后执行的操作（Reset操作）</li>
<li>运行控制，启动计时器</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* GPIO 初始化为输入模式（上拉或浮空） */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 选择时基单元的时钟源，内部时钟源 */</span></span><br><span class="line">	TIM_InternalClockConfig(TIM3);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置时基单元 */</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置输入捕获单元 */</span></span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 选择从模式的触发源，选择触发后执行的操作 */</span></span><br><span class="line">	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);</span><br><span class="line">	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 运行控制，启动计时器 */</span></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PWMI-模式"><a href="#PWMI-模式" class="headerlink" title="PWMI 模式"></a>PWMI 模式</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/Snipaste_2023-04-02_22-01-40.png" alt="Snipaste_2023-04-02_22-01-40"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟</li>
<li>GPIO 初始化为输入模式（上拉或浮空）</li>
<li>配置时基单元</li>
<li>配置输入捕获单元</li>
<li>选择从模式的触发源（TI1FP1）</li>
<li>选择触发后执行的操作（Reset操作）</li>
<li>运行控制，启动计时器</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* GPIO 初始化为输入模式（上拉或浮空） */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 选择时基单元的时钟源，内部时钟源 */</span></span><br><span class="line">	TIM_InternalClockConfig(TIM3);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置时基单元 */</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置输入捕获单元 */</span></span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">	TIM_PWMIConfig(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 选择从模式的触发源，选择触发后执行的操作 */</span></span><br><span class="line">	TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);</span><br><span class="line">	TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 运行控制，启动计时器 */</span></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (TIM_GetCapture2(TIM3) + <span class="number">1</span>) * <span class="number">100</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编码器接口测速"><a href="#编码器接口测速" class="headerlink" title="编码器接口测速"></a>编码器接口测速</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/ADC.jpg" alt="编码器接口基本结构" title="编码器接口基本结构"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟</li>
<li>GPIO 初始化为输入模式</li>
<li>配置时基单元</li>
<li>配置输入捕获单元，包括滤波器、极性参数</li>
<li>配置编码器接口模式</li>
<li>运行控制，启动计时器</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* GPIO 初始化为输入模式 */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置时基单元 */</span></span><br><span class="line">	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;	<span class="comment">// 没用</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;		<span class="comment">//ARR</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;		<span class="comment">//PSC</span></span><br><span class="line">	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置输入捕获单元，包括滤波器、极性参数 */</span></span><br><span class="line">	TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">	TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;</span><br><span class="line">	TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置编码器接口模式 */</span></span><br><span class="line">	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 运行控制，启动计时器 */</span></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int16_t</span> Temp;</span><br><span class="line">	Temp = TIM_GetCounter(TIM3);</span><br><span class="line">	TIM_SetCounter(TIM3, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/Encoder.jpg" alt="ADC基本结构" title="ADC基本结构"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟（ADC和GPIO），配置 ADC_CLK 分频器</li>
<li>GPIO 配置为模拟输入模式</li>
<li>配置多路开关</li>
<li>配置 ADC 转换器</li>
<li>配置看门狗（可选）</li>
<li>开启中断，配置 NVIC（可选）</li>
<li>开启 ADC</li>
<li>对 ADC 进行校准（建议）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置 ADC_CLK 分频器 */</span></span><br><span class="line">	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* GPIO 配置为模拟输入模式 */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置多路开关 */</span></span><br><span class="line">	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 配置 ADC 转换器 */</span></span><br><span class="line">	ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">	ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line">	ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">	ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 开启 ADC */</span></span><br><span class="line">	ADC_Cmd(ADC1, ENABLE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 对 ADC 进行校准 */</span></span><br><span class="line">	ADC_ResetCalibration(ADC1);		<span class="comment">// 复位校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);	<span class="comment">// 等待复位校准完成</span></span><br><span class="line">	ADC_StartCalibration(ADC1);		<span class="comment">// 开始校准</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);		<span class="comment">// 等待校准完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	ADC_SoftwareStartConvCmd(ADC1, ENABLE);			<span class="comment">// 软件触发转换</span></span><br><span class="line">	<span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);	<span class="comment">// 等待转换完成</span></span><br><span class="line">	<span class="keyword">return</span> ADC_GetConversionValue(ADC1);			<span class="comment">// 读取 ADC 转换结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/USART.jpg" alt="DMA基本结构" title="DMA基本结构"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟</li>
<li>初始化 DMA（包括外设和存储器的各个数据、方向、传输计数器、是否需要自动重装、选择触发源、通道优先级）</li>
<li>若为硬件触发，开启对应 DMA 输出（可选）</li>
<li>开启中断输出，配置 NVIC（可选）</li>
<li>开启 DMA</li>
</ul>
</li>
</ul>
<blockquote>
<p>改变传输寄存器时需先失能，写入值后再使能</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA, <span class="type">uint32_t</span> AddrB, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyDMA_Size = Size;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化 DMA */</span></span><br><span class="line">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;			<span class="comment">// 外设起始地址</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	<span class="comment">// 外设数据宽度</span></span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;		<span class="comment">// 外设是否自增</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;;				<span class="comment">// 存储器起始地址</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;;	<span class="comment">// 存储器数据宽度</span></span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;;		<span class="comment">// 存储器是否自增</span></span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;	<span class="comment">// 传输方向</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = Size;		<span class="comment">// 缓冲区大小，即传输寄存器</span></span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;		<span class="comment">// 传输模式，即是否使用自动重装</span></span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;		<span class="comment">// 选择是否存储器到存储器，即选择硬件触发或软件触发</span></span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;	<span class="comment">// 优先级</span></span><br><span class="line">	DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 开启 DMA */</span></span><br><span class="line">    DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* DMA失能、设置当前数据寄存器、DMA使能 */</span></span><br><span class="line">	DMA_Cmd(DMA1_Channel1, DISABLE);</span><br><span class="line">	DMA_SetCurrDataCounter(DMA1_Channel1, MyDMA_Size);</span><br><span class="line">	DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 等待转运完成、清除转运完成标志位 */</span></span><br><span class="line">	<span class="keyword">while</span> (DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">	DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="USART-串口"><a href="#USART-串口" class="headerlink" title="USART 串口"></a>USART 串口</h2><p><img src="/images/loading.gif" data-original="http://images.studysomething.top/img/DMA.jpg" alt="USART基本结构" title="USART基本结构"></p>
<ul>
<li>具体步骤<ul>
<li>RCC 开启时钟（USART和GPIO）</li>
<li>GPIO设置（TX配置为复用输出、RX配置为输入）</li>
<li>配置USART</li>
<li>开启中断、配置NVIC（可选）</li>
<li>开启USART</li>
</ul>
</li>
</ul>
<ol>
<li>发送数据</li>
</ol>
<p>初始化函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* RCC 开启时钟 */</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* GPIO设置 */</span></span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;		<span class="comment">// 复用推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 配置USART */</span></span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;						<span class="comment">// 波特率</span></span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;		<span class="comment">// 硬件流控制</span></span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Tx;						<span class="comment">// 串口模式</span></span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;					<span class="comment">// 校验位</span></span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;					<span class="comment">// 停止位</span></span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;				<span class="comment">// 字长</span></span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 开启USART */</span></span><br><span class="line">	USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关函数封装：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  发送一个字节</span></span><br><span class="line"><span class="comment">  * @param  Byte: 要发送的字节数据</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_SendData(USART1, Byte);</span><br><span class="line">	<span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  发送一个数组</span></span><br><span class="line"><span class="comment">  * @param  Array: 数组的首地址，必须为 uint8_t 类型的数组</span></span><br><span class="line"><span class="comment">  * @param  Length: 数组的长度</span></span><br><span class="line"><span class="comment">  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Array[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  发送字符串</span></span><br><span class="line"><span class="comment">  * @param  String: 字符串的首地址</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(String[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  指数函数，即X的Y次方</span></span><br><span class="line"><span class="comment">  * @param  X：底数</span></span><br><span class="line"><span class="comment">  * @param  Y：指数</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (Y --)</span><br><span class="line">	&#123;</span><br><span class="line">		Result *= X;	<span class="comment">// 1 乘以X Y次</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  发送数字</span></span><br><span class="line"><span class="comment">  * 	本质将数字手动转为字符串然后发送</span></span><br><span class="line"><span class="comment">  * @param  Number</span></span><br><span class="line"><span class="comment">  * @param  Length</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);	<span class="comment">// 发送Number的每一位（高位先行）&#x27;0&#x27;-&gt;偏移</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  fputc重定向</span></span><br><span class="line"><span class="comment">  * @param  </span></span><br><span class="line"><span class="comment">  * @retval </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(ch);</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  模拟printf重写打印字符串函数</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">	va_list arg;</span><br><span class="line">	va_start(arg, format);</span><br><span class="line">	<span class="built_in">vsprintf</span>(String, format, arg);</span><br><span class="line">	va_end(arg);</span><br><span class="line">	Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>printf 重定向方法3：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String, <span class="string">&quot;\r\nNum3=%d&quot;</span>, <span class="number">333</span>);</span><br><span class="line">Serial_SendString(String);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接收数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	<span class="comment">// 上拉输入</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Rx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 开启中断 */</span></span><br><span class="line">	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* NVIC 分组 */</span></span><br><span class="line">	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* NVIC 配置 */</span></span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  获取标志位</span></span><br><span class="line"><span class="comment">  * @param  Nonw</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  获取串口数据</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> Serial_RxData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  串口1中断函数</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		Serial_RxData = USART_ReceiveData(USART1);	<span class="comment">// 获取数据</span></span><br><span class="line">		Serial_RxFlag = <span class="number">1</span>;				<span class="comment">// 标志位置1</span></span><br><span class="line">		USART_ClearITPendingBit(USART1, USART_IT_RXNE);	<span class="comment">// 清空终端挂起位</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>收发 HEX 数据包</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  发送数据包</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">	Serial_SendArray(Serial_TxPacket, <span class="number">4</span>);</span><br><span class="line">	Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  中断程序中接收数据包</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;		<span class="comment">// 当前状态</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;		<span class="comment">// 接收到第几个数据</span></span><br><span class="line">	<span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (RxState == <span class="number">0</span>)		<span class="comment">// 状态0：包头</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="number">0xFF</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">1</span>;	<span class="comment">// 进入状态1</span></span><br><span class="line">				pRxPacket = <span class="number">0</span>;	<span class="comment">// 接收数据指针置零</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)				<span class="comment">// 状态1：数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			Serial_RxPacket[pRxPacket] = RxData;	<span class="comment">// 接收数据</span></span><br><span class="line">			pRxPacket ++;				<span class="comment">// 指针后移</span></span><br><span class="line">			<span class="keyword">if</span> (pRxPacket &gt;= <span class="number">4</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">2</span>;		<span class="comment">// 进入状态3</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)			<span class="comment">// 状态2：包尾</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (RxData == <span class="number">0xFE</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RxState = <span class="number">0</span>;		<span class="comment">// 重新进入状态0</span></span><br><span class="line">				Serial_RxFlag = <span class="number">1</span>;	<span class="comment">// 置接收标志位为1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大学生电子设计竞赛</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>verilog编写猫狗过河实验</title>
    <url>/posts/34498.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>源代码地址：<a href="https://github.com/penggeon/catanddog">https://github.com/penggeon/catanddog</a></p>
<p><a href="https://github.com/penggeon/catanddog"><img src="/images/loading.gif" data-original="https://github-readme-stats.vercel.app/api/pin/?username=penggeon&repo=catanddog" alt="catanddog"></a></p>
<div class="note warning no-icon modern"><p>仅给出了实验过程的源代码，需手动复制粘贴至自己项目中。</p>
<p>主模块默认名为 <code>catanddog</code>，若需使用请自行修改。</p>
</div>

<h1 id="设计课题的任务要求"><a href="#设计课题的任务要求" class="headerlink" title="设计课题的任务要求"></a>设计课题的任务要求</h1><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>一个人要将 1 只狗、 1 只猫、 1 只老鼠渡过河，独木舟一次只能装载人和一只动物，但猫和狗不能单独在一起，而猫和老鼠也不能友好相处，试模拟这个人将三只动物安全渡过河的过程。</p>
<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><p>1、 SW6 作为整机开关， SW6&#x3D;0 为关机状态， 点阵、 数码管和发光二极管为全灭状态；</p>
<p>SW6&#x3D;1 时，启动游戏，在 8× 8 点阵显示猫、狗、鼠均在左岸的情况（如图 3-1 所示），其中红色方块表示猫， 绿色方块表示狗， 黄色方块表示鼠； 数码管 DISP1-DISP0显示渡河次数，启动时显示“00”； LD15 和 LD0 显示独木舟所在位置， LD15 亮表示独木舟在左岸， LD0 亮表示独木舟在右岸，启动时独木舟在左岸；</p>
<p> <img src="/images/loading.gif" data-original="http://images.studysomething.top/img/image-20230408142754845.png" alt="image-20230408142754845"></p>
<p><em>图表 1 启动时点阵图案</em></p>
<p>2、 BTN0 为复位键，任何时候按下复位都重新启动游戏；</p>
<p>3、 BTN7 代表猫， BTN6 代表狗， BTN5 代表鼠，按下对应的按键表示带该动物过河，同时点阵上显示过河动画。 例如按下 BTN6 选择狗，点阵按图 3-2 所示过程显示过河动画，每秒切换一幅图案；</p>
<p> <img src="/images/loading.gif" data-original="http://images.studysomething.top/img/image-20230408142819955.png" alt="image-20230408142819955"></p>
<p><em>图表 2 狗从左岸到右岸的点阵动画过程</em></p>
<p>4、 带某动物过河时要求独木舟和该动物在河的同侧， 如果不在同侧，则按键无效；</p>
<p>5、 BTN4 代表独木舟单独往返，按下后在 LD0<del>LD15 上显示渡河过程，根据独木舟当前所在位置，依次点亮 LD0</del>LD15 或 LD15~LD0，每 0.25 秒切换一个 LED；</p>
<p>6、 在数码管 DISP1-DISP0 显示渡河次数， 带动物过河或者独木舟单独往返渡河次数均加 1；</p>
<p>7、 将三只动物全部带到右岸则游戏成功， LD0~LD15 全亮表示成功，按 BTN0 可重新启动游戏；</p>
<p>8、 如果出现猫和鼠或者猫和狗单独在河的某侧，则游戏失败， LD0~LD15 全灭表示失败，按 BTN0 可重新启动游戏。</p>
<h2 id="提高要求"><a href="#提高要求" class="headerlink" title="提高要求"></a>提高要求</h2><p>1、 游戏难度可以设置，不同难度要在不同的渡河次数之内完成游戏，在规定步数内未完成游戏则为失败；</p>
<p>2、 在不同情况下播放不同的音效或乐曲；</p>
<p>3、 自拟其它功能。</p>
<h1 id="系统设计（设计思路、总体框图、分块设计）"><a href="#系统设计（设计思路、总体框图、分块设计）" class="headerlink" title="系统设计（设计思路、总体框图、分块设计）"></a>系统设计（设计思路、总体框图、分块设计）</h1><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>模块化设计，自顶向下设计，自下向上实现。</p>
<p>时钟分频模块将1kHz时钟分频为4Hz与0.25Hz供其他模块使用，消抖模块将按钮经过消抖输出有效短脉冲信号，计数器模块产生需要的计数器供其他模块使用，LED模块、点阵模块、数码管模块、蜂鸣器模块实现底层功能，Main模块实现主要的游戏逻辑。</p>
<h2 id="总体框图"><a href="#总体框图" class="headerlink" title="总体框图"></a>总体框图</h2><p> <img src="/images/loading.gif" data-original="http://images.studysomething.top/img/image-20230408142837394.png" alt="image-20230408142837394"></p>
<p><em>图表 3 总体框图</em></p>
<h2 id="分块设计"><a href="#分块设计" class="headerlink" title="分块设计"></a>分块设计</h2><h3 id="顶层模块"><a href="#顶层模块" class="headerlink" title="顶层模块"></a>顶层模块</h3><p>顶层模块负责各自模块之间的连接</p>
<h3 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h3><p>Main模块，负责主要逻辑的实现。</p>
<p>包括按下各个按钮后标志位的更新、游戏状态实时更新，正常游戏时猫、狗、鼠位置变量的变换即过河动画，复位键按下后标志位置初始值、位置变量置零等操作。</p>
<h3 id="时钟分频模块（系列）"><a href="#时钟分频模块（系列）" class="headerlink" title="时钟分频模块（系列）"></a>时钟分频模块（系列）</h3><p>时钟频率选用1kHz，项目中需要采用其他频率时钟，故而进行时钟分频。</p>
<p>包括divide_4Hz，divide_025Hz两个时钟分频模块，分别产生4Hz时钟与0.25Hz时钟。</p>
<h3 id="计数器模块（系列）"><a href="#计数器模块（系列）" class="headerlink" title="计数器模块（系列）"></a>计数器模块（系列）</h3><p>项目设计中需要各种计数器，故将计数器单独拿出，封装为了不同的模块。</p>
<p>包括Counter_8，Counter_2，Counter_2_025Hz，Counter_8_4Hz四个计数器模块，前两者分别是1kHz时钟下产生的模8计数器与模2计数器，后两者分别是0.25Hz时钟下产生的模8计数器与模2计数器。</p>
<h3 id="消抖模块"><a href="#消抖模块" class="headerlink" title="消抖模块"></a>消抖模块</h3><p>由于机械按键按下后可能会产生抖动，导致一次的按键按下事件被识别为多次按键按下，故按键信号均需经过消抖模块进行处理。该项目利用debounce模块进行消抖。</p>
<h3 id="LED模块"><a href="#LED模块" class="headerlink" title="LED模块"></a>LED模块</h3><p>LED模块采用组合逻辑设计。</p>
<p>第一步判断开机拨码sw6，sw6为0时输出信号全为0，sw6为1时继续判断。</p>
<p>第二步判断难度设置拨码sw5，sw5为1时根据counter_2_025Hz计数器输出信号来实现LED的闪烁效果，表示此时正处于难度设置中，sw5为0时继续判断。</p>
<p>第三步判断游戏状态标志位，若成功，则LED输出信号全为1，若失败，则LED输出信号全为0，若正在处于游戏中，则根据Main模块的输出信号cnt_canoe来判断此时的独木舟处于何处，并正确显示。</p>
<h3 id="点阵模块"><a href="#点阵模块" class="headerlink" title="点阵模块"></a>点阵模块</h3><p>点阵模块采用组合逻辑设计。</p>
<p>第一步判断开机拨码sw6，sw6为0时行信号输出为1，列信号输出为0，sw6为1时继续判断。</p>
<p>第二步判断难度设置拨码sw5。</p>
<p>若sw为1，则根据游戏难度，显示不同的动画，提示用户不同的游戏难度，其中点阵行扫描采用计数器Counter_8的输出信号实现。</p>
<p>若sw为0，则根据游戏状态，显示不同的动画。</p>
<p>游戏失败：显示叉号。</p>
<p>游戏成功：显示对勾。</p>
<p>游戏进行中：通过Main的输出信号判断猫、狗、鼠的位置显示不同的点阵动画。</p>
<h3 id="数码管模块"><a href="#数码管模块" class="headerlink" title="数码管模块"></a>数码管模块</h3><p>数码管模块采用组合逻辑设计。</p>
<p>第一步判断开机拨码sw6，sw6为0时阴极信号cat全为1，阳极信号seg全为0，sw6为1时继续判断。</p>
<p>第二步判断模2计数器输出信号，判断是显示个位还是十位。</p>
<p>第三步判断难度设置拨码sw5。</p>
<p>若sw为1，则根据游戏难度，显示不同的数字（个位与十位不同），提示用户不同的渡河次数限制。</p>
<p>若sw为0，则根据游戏状态，显示不同的动画。</p>
<p>游戏失败：显示HH，表示失败。</p>
<p>游戏成功：显示UU，表示成功。</p>
<p>游戏进行中：通过Main的输出信号tens与ones分别显示当前的渡河次数。</p>
<h3 id="蜂鸣器模块"><a href="#蜂鸣器模块" class="headerlink" title="蜂鸣器模块"></a>蜂鸣器模块</h3><p>蜂鸣器模块采用组合逻辑设计。</p>
<p>第一步判断开机拨码sw6，sw6为0时蜂鸣器输出信号为0，，sw6为1时继续判断。</p>
<p>第二步判断开机拨码sw5，sw6为1时蜂鸣器输出信号为0，，sw6为0时继续判断。</p>
<p>第三步判断游戏状态，通过count_8_4Hz信号改变蜂鸣器输出。</p>
<p>游戏失败：输出周期1s，占空比为25%的信号。</p>
<p>游戏成功：输出周期0.5s，占空比为50%的信号。</p>
<p>游戏进行中：输出信号为0。</p>
<h1 id="功能说明及资源利用情况"><a href="#功能说明及资源利用情况" class="headerlink" title="功能说明及资源利用情况"></a>功能说明及资源利用情况</h1><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><h3 id="拨码开关"><a href="#拨码开关" class="headerlink" title="拨码开关"></a>拨码开关</h3><p>拨码开关sw6为总开关，只有拨上sw6才能正常进行游戏。</p>
<p>拨码开关sw5为游戏难度设置，当sw5拨上时，每隔4s切换一次游戏难度，游戏难度由0到3依次变换，难度默认为0。当难度为0时，最多渡河次数为15次；难度为1时，最多渡河次数为13次；难度为2时，最多渡河次数为9次；难度为3时，最多渡河次数为6次</p>
<h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><p>按键BTN7为猫过河按键，按下猫过河。</p>
<p>按键BTN6为狗过河按键，按下狗过河。</p>
<p>按键BTN5为鼠过河按键，按下鼠过河。</p>
<p>按键BTN4为独木舟过河按键，按下独木舟单独过河。</p>
<p>按键BTN0为复位建，按下游戏复位。</p>
<h3 id="游戏难度设置"><a href="#游戏难度设置" class="headerlink" title="游戏难度设置"></a>游戏难度设置</h3><p>处于游戏难度设置时，LED灯闪烁，数码管提示次数，点阵显示难度。</p>
<p>难度为0时，数码管显示15，点阵显示绿色小火。</p>
<p>难度为1时，数码管显示13，点阵显示绿色中火。</p>
<p>难度为2时，数码管显示9，点阵显示黄色中火。</p>
<p>难度为3时，数码管显示7，点阵显示红色大火。</p>
<h3 id="游戏状态"><a href="#游戏状态" class="headerlink" title="游戏状态"></a>游戏状态</h3><p>游戏成功时，LED灯全亮，点阵显示对勾，数码管显示UU，蜂鸣器间断蜂鸣，占空比为25%。</p>
<p>游戏失败时，LED灯全灭，点阵显示叉号，数码管显示HH，蜂鸣器间断蜂鸣，占空比为50%。</p>
<h2 id="资源利用情况"><a href="#资源利用情况" class="headerlink" title="资源利用情况"></a>资源利用情况</h2><h3 id="晶振时钟"><a href="#晶振时钟" class="headerlink" title="晶振时钟"></a>晶振时钟</h3><p>利用情况：利用</p>
<p>使用1kHz时钟作为总时钟输入。</p>
<h3 id="SW拨码"><a href="#SW拨码" class="headerlink" title="SW拨码"></a>SW拨码</h3><p>利用情况：SW6，SW5</p>
<p>SW6，游戏开关拨码。</p>
<p>SW5，游戏难度设置拨码。</p>
<h3 id="BTN按钮"><a href="#BTN按钮" class="headerlink" title="BTN按钮"></a>BTN按钮</h3><p>利用情况：BTN7，BTN6，BTN5，BTN4，BTN0</p>
<p>BTN７，猫过河按键。</p>
<p>BTN６，狗过河按键。</p>
<p>BTN５，鼠过河按键。</p>
<p>BTN４，独木舟单独过河按键。</p>
<p>BTN０，复位键。</p>
<h3 id="LED灯"><a href="#LED灯" class="headerlink" title="LED灯"></a>LED灯</h3><p>利用情况：LED15~0</p>
<p>作用：表示游戏难度设置，游戏成功，游戏失败，独木舟位置</p>
<h3 id="点阵"><a href="#点阵" class="headerlink" title="点阵"></a>点阵</h3><p>利用情况：row15<del>0，col_r15</del>0，col_g15~0</p>
<p>作用：表示游戏难度设置，游戏成功，游戏失败，猫狗鼠位置</p>
<h3 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h3><p>利用情况：DISP1~0</p>
<p>作用：表示最多渡河次数，游戏成功，游戏失败，当前渡河次数</p>
<h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3><p>利用情况：利用</p>
<p>作用：表示游戏成功，游戏失败</p>
<h1 id="故障及问题分析"><a href="#故障及问题分析" class="headerlink" title="故障及问题分析"></a>故障及问题分析</h1><h2 id="组合逻辑与时序逻辑"><a href="#组合逻辑与时序逻辑" class="headerlink" title="组合逻辑与时序逻辑"></a>组合逻辑与时序逻辑</h2><p>原本LED、点阵、数码管与蜂鸣器模块是采用时序逻辑实现的，但在仿真以及下载中出现了问题，实现现象为各个输出信号均无法确定。</p>
<p>由于这些模块并不需要每隔一段时间更改一次，于是改为采用组合逻辑实现。只需根据不同的情况，使输出连接不同的信号即可。</p>
<h2 id="时序逻辑always块设计"><a href="#时序逻辑always块设计" class="headerlink" title="时序逻辑always块设计"></a>时序逻辑always块设计</h2><p>在 <code>always@(posedge clk or posedge btn7 or posedge btn6)</code> 之类的 always 块中，应当首先判断 btn7、btn6 是否按下即</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(btn7)<span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (btn6)beign</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> beign</span><br><span class="line">	<span class="comment">// 此处编写时钟上升沿触发后的逻辑</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>反之，若在 if 中判断诸如 sw6 或者敏感条件列表中不存在的信号，会报错，硬件是不支持这样设计的。<br>若需在 btn7 按下同时判断 sw6 ，可以采用以下代码实现</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(btn7)<span class="keyword">begin</span></span><br><span class="line">   If(sw6)<span class="keyword">begin</span></span><br><span class="line">		<span class="comment">// 此处编写正常逻辑</span></span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="总结和结论"><a href="#总结和结论" class="headerlink" title="总结和结论"></a>总结和结论</h1><h2 id="Verilog设计"><a href="#Verilog设计" class="headerlink" title="Verilog设计"></a>Verilog设计</h2><p>Verilog设计时应采用自顶向下设计，自下向上实现的思路。在各个模块中实现简单或目标清晰的功能，确认各模块功能正常后，拼接子模块，实现整体功能的实现。</p>
<h2 id="猫狗过河实现思路"><a href="#猫狗过河实现思路" class="headerlink" title="猫狗过河实现思路"></a>猫狗过河实现思路</h2><p>猫狗过河实验中重要的一些变量（reg型）为标志位，各个子模块（LED、点阵等模块）可根据标志位改变自己的输出信号，而不需要关心标志位的更改。</p>
<p>在Main模块中实现主要的功能，此时可以更改标志位，表示猫的位置，或独木舟的位置，以及游戏是否成功等，而不需要关心在具体的状态时底层如何显示。</p>
]]></content>
      <tags>
        <tag>verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉模块</title>
    <url>/posts/6413.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="openmv"><a href="#openmv" class="headerlink" title="openmv"></a>openmv</h1><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p><strong>1、网址</strong></p>
<p>中文官网：<a href="https://singtown.com/openmv/">星瞳科技</a></p>
<p>教程：<a href="https://book.openmv.cc/quick-starter.html">上手教程</a></p>
<p>文档：<a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/index.html">中文文档</a></p>
<p>所有对象及方法：<a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/index.html#openmv-cam">特定于OpenMV Cam的库</a></p>
<p><strong>2、查找手册</strong></p>
<p>所有外设概述：<a href="https://book.openmv.cc/MCU/pyb.html">pyb各种外设</a></p>
<p>串口：<a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.UART.html">UART类 – 双向串行通信总线</a></p>
<p>电机：<a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/pyb.Servo.html">Servo类 –三线hobby舵机驱动</a></p>
<h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><p>寻找色块：<a href="https://book.openmv.cc/quick-starter.html#%E8%BF%BD%E8%B8%AA%E5%B0%8F%E7%90%83">追踪小球</a> （官网写着追踪小球，但其实是寻找色块）</p>
<p>模版匹配（单）：<a href="https://book.openmv.cc/image/template-match.html">模版匹配NCC</a></p>
<p>模版匹配（多）：<a href="https://book.openmv.cc/image/mulity-template-match.html">多模版匹配NCC</a></p>
<p>串口通信（只发送一个字节）：<a href="https://book.openmv.cc/MCU/serial1.html#%E4%BB%8B%E7%BB%8D">介绍</a></p>
<p>巡线小车：<a href="https://book.openmv.cc/project/follow-lines.html#%E8%B0%83%E6%95%B4%E5%8F%82%E6%95%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%B7%9F%E9%9A%8F">巡线小车</a></p>
<h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><p><strong>1、JSON</strong></p>
<p>以下的代码即可完成JSON的转换。</p>
<p>文档：<a href="https://docs.singtown.com/micropython/zh/latest/openmvcam/library/ujson.html">https://docs.singtown.com/micropython/zh/latest/openmvcam/library/ujson.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">json.dumps(your_data)</span><br></pre></td></tr></table></figure>

<p>有时可以使用python的字符串格式化的功能代替JSON，例如下面的代码是一样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output_str=<span class="string">&quot;[%d,%d]&quot;</span> % (max_blob.cx(),max_blob.cy()) <span class="comment">#方式1</span></span><br><span class="line">output_str=json.dumps([max_blob.cx(),max_blob.cy()]) <span class="comment">#方式2</span></span><br></pre></td></tr></table></figure>

<p><strong>2、其他</strong></p>
<p>自己学的时候写了个定时器定时中断控制灯的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pyb</span><br><span class="line"><span class="keyword">from</span> pyb <span class="keyword">import</span> LED, Timer</span><br><span class="line"></span><br><span class="line">rled = LED(<span class="number">1</span>) <span class="comment"># 红led</span></span><br><span class="line">bled = LED(<span class="number">2</span>) <span class="comment"># 绿led</span></span><br><span class="line">gled = LED(<span class="number">3</span>) <span class="comment"># 蓝led</span></span><br><span class="line"></span><br><span class="line">tim = Timer(<span class="number">4</span>, freq=<span class="number">1</span>) <span class="comment"># 1Hz触发TIM4定时器</span></span><br><span class="line">tim.callback(<span class="keyword">lambda</span> t: rled.toggle())</span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    </span><br><span class="line">    bled.on()</span><br><span class="line">    gled.off()</span><br><span class="line">    pyb.delay(<span class="number">500</span>)</span><br><span class="line">    gled.on()</span><br><span class="line">    bled.off()</span><br><span class="line">    pyb.delay(<span class="number">500</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(clock.fps())</span><br></pre></td></tr></table></figure>

<h1 id="k210"><a href="#k210" class="headerlink" title="k210"></a>k210</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>1、概述</strong></p>
<p>嘉楠科技：<a href="https://www.canaan-creative.com/">嘉楠科技</a></p>
<p>勘智K210：<a href="https://www.canaan-creative.com/product/kendryteai">勘智K210</a></p>
<p>K210视觉识别模块：<a href="https://www.yahboom.com/tbdetails?id=546">K210视觉识别模块</a></p>
<p>购买：<a href="https://detail.tmall.com/item.htm?id=711688603937">亚博智能 K210视觉识别模块CanMV传感器AI机器摄像头Python开发板</a></p>
<p><strong>2、学习资料</strong></p>
<p>K210视觉识别模块教程：<a href="https://www.yahboom.com/study/K210-AI-Camera">K210视觉识别模块学习专区 - 亚博智能</a></p>
<p>CanMV文档：<a href="https://developer.canaan-creative.com/index.html?channel=developer#/document/canmv">https://developer.canaan-creative.com/index.html?channel=developer#/document/canmv</a></p>
<p>CanMV API 手册：<a href="https://developer.canaan-creative.com/index.html?channel=developer#/document/canmv">https://developer.canaan-creative.com/index.html?channel=developer#/document/canmv</a></p>
<h2 id="数字识别"><a href="#数字识别" class="headerlink" title="数字识别"></a>数字识别</h2><p><strong>1、介绍</strong></p>
<p>自主学习分类：<a href="https://www.yahboom.com/build.html?id=6145&cid=580">自主学习分类</a></p>
<p><strong>2、模型训练</strong></p>
<p>哔哩哔哩教程：<a href="https://www.bilibili.com/video/BV1Ga4y1H79J/?spm_id_from=333.337.search-card.all.click&vd_source=c6a75c082f96f79b814a4b6c18035936">基于MaixHub与K210模型训练和实时目标检测（入门版）</a></p>
<p>MaixHub：<a href="https://maixhub.com/">https://maixhub.com/</a></p>
<p>labelimg 下载：<a href="https://blog.csdn.net/dulingwen/article/details/88840703">Windows 10下安装labelImg标注工具！</a></p>
<div class="note info no-icon modern"><p>模型训练：<a href="https://qichenxi.blog.csdn.net/article/details/121044449">Mx-yolov3+Maixpy+ K210进行本地模型训练和目标检测</a></p>
<p>大佬博客：<a href="https://qichenxi.blog.csdn.net/?type=blog">我与nano</a></p>
<p>Sipeed 资料站：<a href="https://wiki.sipeed.com/">Sipeed 资料站 - Sipeed Wiki</a></p>
</div>]]></content>
      <categories>
        <category>大学生电子设计竞赛</category>
      </categories>
      <tags>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
</search>
